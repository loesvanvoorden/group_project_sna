---
title: "Electoral Cycle Network Analysis: Dutch Parliament 2023-2024"
subtitle: "Pre-Election vs. Post-Formation Party Cooperation Networks"
author: "Your Name"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: show
    theme: flatly
    highlight: tango
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  results = 'asis',
  fig.width = 12,
  fig.height = 8,
  fig.path = "results/visualizations/"
)
print(paste("Working directory set to:", getwd()))
```

------------------------------------------------------------------------

# 1. Data Preparation

## 1.1 Load Data

```{r load-data}
# Load voting data
voting_data_2023 <- read.csv("data/voting_data_2023_preelection.csv", stringsAsFactors = FALSE)
voting_data_2024 <- read.csv("data/voting_data_clean.csv", stringsAsFactors = FALSE)

# Convert dates
voting_data_2023$date <- lubridate::ymd_hms(voting_data_2023$GewijzigdOp)
voting_data_2024$date <- lubridate::ymd_hms(voting_data_2024$GewijzigdOp)

# Load Kieskompas ideology data
ideology_data <- read.csv("data/political_axes_data.csv", stringsAsFactors = FALSE)
names(ideology_data) <- c("left_right", "conservative_progressive", "party")
ideology_data <- ideology_data[!is.na(ideology_data$party) & ideology_data$party != "", ]

print("Data loaded:")
print(sprintf("  • 2023 records: %s", format(nrow(voting_data_2023), big.mark = ",")))
print(sprintf("  • 2024 records: %s", format(nrow(voting_data_2024), big.mark = ",")))
print(sprintf("  • Ideology data: %d parties", nrow(ideology_data)))
```

## 1.2 General Preprocessing: Extract Motion Datasets

```{r general-preprocessing}
# Key dates
election_date <- lubridate::ymd("2023-11-22")
formation_date <- lubridate::ymd("2024-07-05")

# Extract motion dataset 1 year BEFORE election (Nov 22, 2022 - Nov 21, 2023)
pre_election_start <- election_date - lubridate::years(1)
pre_election_end <- election_date - lubridate::days(1)
motion_data_pre <- voting_data_2023[voting_data_2023$date >= pre_election_start & 
                                     voting_data_2023$date <= pre_election_end, ]

# Extract motion dataset 1 year AFTER formation (Jul 5, 2024 - Jul 4, 2025)
post_formation_start <- formation_date
post_formation_end <- formation_date + lubridate::years(1)
motion_data_post <- voting_data_2024[voting_data_2024$date >= post_formation_start & 
                                     voting_data_2024$date <= post_formation_end, ]

# Filter to valid parties (from ideology data)
valid_parties <- ideology_data$party
motion_data_pre <- motion_data_pre[motion_data_pre$ActorFractie %in% valid_parties, ]
motion_data_post <- motion_data_post[motion_data_post$ActorFractie %in% valid_parties, ]

print("GENERAL PREPROCESSING")
print("====================")
print(sprintf("Pre-election: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_pre), big.mark = ","),
              format(length(unique(motion_data_pre$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_pre$ActorFractie))))
print(sprintf("Post-formation: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_post), big.mark = ","),
              format(length(unique(motion_data_post$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_post$ActorFractie))))
```

## 1.3 Load Pre-Generated Edge Lists

Edge lists are now generated by the Python script `generate_edgelists.py` and loaded from CSV files.

```{r load-edgelists}
# Load pre-generated edge lists from Python script
edgelist_pre <- read.csv("results/edge_lists/edges_pre_election.csv", stringsAsFactors = FALSE)
edgelist_post <- read.csv("results/edge_lists/edges_post_formation.csv", stringsAsFactors = FALSE)

print("EDGE LISTS LOADED")
print("=================")
print("Edge lists generated by generate_edgelists.py")
print(sprintf("Pre-election edges: %d", nrow(edgelist_pre)))
print(sprintf("Post-formation edges: %d", nrow(edgelist_post)))
```

## 1.4 Create Fully Connected Networks

Study 1 (QAP) requires fully connected networks, while Study 2 (ERGM) uses binary networks. We create fully connected networks first, then binarize for ERGM analysis.

```{r fully-connected-networks}
# Create nodelist from ideology data (like final_ergm.R approach)
nodelist <- data.frame(
  name = sort(ideology_data$party),
  left_right = ideology_data$left_right[match(sort(ideology_data$party), ideology_data$party)],
  conservative_progressive = ideology_data$conservative_progressive[match(sort(ideology_data$party), ideology_data$party)],
  stringsAsFactors = FALSE
)

# Create igraph networks directly (like final_ergm.R)
g_pre <- igraph::graph_from_data_frame(d = edgelist_pre, vertices = nodelist, directed = FALSE)
g_post <- igraph::graph_from_data_frame(d = edgelist_post, vertices = nodelist, directed = FALSE)

# Generate adjacency matrices
adj_matrix_pre <- igraph::as_adjacency_matrix(g_pre, attr = "weight", sparse = FALSE)
adj_matrix_post <- igraph::as_adjacency_matrix(g_post, attr = "weight", sparse = FALSE)

# Set 0 values to 1e-6 to make fully connected (but keep diagonal as 0)
adj_matrix_pre[adj_matrix_pre == 0] <- 1e-6
adj_matrix_post[adj_matrix_post == 0] <- 1e-6
diag(adj_matrix_pre) <- 0
diag(adj_matrix_post) <- 0

# Regenerate fully connected networks
g_pre_connected <- igraph::graph_from_adjacency_matrix(adj_matrix_pre, 
                                                       mode = "undirected", 
                                                       weighted = TRUE)
g_post_connected <- igraph::graph_from_adjacency_matrix(adj_matrix_post, 
                                                        mode = "undirected", 
                                                        weighted = TRUE)

# Vertex names are already set from nodelist

print("FULLY CONNECTED NETWORKS CREATED")
print("=================================")
print(sprintf("Pre-election: %d nodes, fully connected (%d edges)", 
              nrow(nodelist), snafun::count_edges(g_pre_connected)))
print(sprintf("Post-formation: %d nodes, fully connected (%d edges)", 
              nrow(nodelist), snafun::count_edges(g_post_connected)))
print("All zero edge weights set to 1e-6 for full connectivity")
print("Networks ready for Study 1 (QAP); Study 2 (ERGM) will use binary versions")

# Export adjacency matrices
if(!dir.exists("results/adjacency_matrices")) {
  dir.create("results/adjacency_matrices", recursive = TRUE)
}
write.csv(adj_matrix_pre, "results/adjacency_matrices/pre_election_adjacency.csv", 
          row.names = TRUE)
write.csv(adj_matrix_post, "results/adjacency_matrices/post_formation_adjacency.csv", 
          row.names = TRUE)
print("Adjacency matrices exported")
```

------------------------------------------------------------------------

# 2. Data Exploration

## 2.1 Ideology Correlation

```{r ideology-correlation}
# Pearson correlation between ideology dimensions
pearson_test <- stats::cor.test(ideology_data$left_right, 
                         ideology_data$conservative_progressive, 
                         method = "pearson")

print("IDEOLOGY CORRELATION")
print("====================")
print(sprintf("Pearson r = %.3f (p = %.4f)", pearson_test$estimate, pearson_test$p.value))

# Scatterplot
plot(ideology_data$left_right, ideology_data$conservative_progressive,
     xlab = "Left-Right", ylab = "Conservative-Progressive",
     main = sprintf("Ideology Dimensions (r = %.3f)", pearson_test$estimate),
     pch = 19, col = "steelblue")
abline(lm(conservative_progressive ~ left_right, data = ideology_data), 
       col = "red", lwd = 2)
text(ideology_data$left_right, ideology_data$conservative_progressive, 
     labels = ideology_data$party, pos = 3, cex = 0.7)
```

## 2.2 Vote Unanimity

```{r vote-unanimity}
# Calculate agreement rates per motion
calculate_agreement_rate <- function(data) {
  unique_votes <- data[, c("Besluit_Id", "ActorFractie", "Soort")]
  unique_votes <- unique_votes[!duplicated(unique_votes), ]
  unique_motions <- unique(unique_votes$Besluit_Id)
  
  agreement_rates <- sapply(unique_motions, function(motion_id) {
    motion_votes <- unique_votes[unique_votes$Besluit_Id == motion_id, ]
    voor <- sum(motion_votes$Soort == "Voor")
    tegen <- sum(motion_votes$Soort == "Tegen")
    total <- nrow(motion_votes)
    pmax(voor, tegen) / total
  })
  return(agreement_rates)
}

# Calculate for both periods
agreement_pre <- calculate_agreement_rate(motion_data_pre)
agreement_post <- calculate_agreement_rate(motion_data_post)

print("VOTE UNANIMITY")
print("==============")
print(sprintf("Pre-election: Mean agreement = %.3f", mean(agreement_pre)))
print(sprintf("Post-formation: Mean agreement = %.3f", mean(agreement_post)))

# Comparison boxplot
boxplot(list(Pre = agreement_pre, Post = agreement_post),
        main = "Agreement Rate Comparison",
        ylab = "Agreement Rate", col = c("#E74C3C", "#3498DB"))
```

## 2.3 Network Visualizations

```{r network-visualizations}

# Create networks for visualization (reuse nodelist from earlier)
g_pre_viz <- igraph::graph_from_data_frame(d = edgelist_pre, vertices = nodelist, directed = FALSE)
g_post_viz <- igraph::graph_from_data_frame(d = edgelist_post, vertices = nodelist, directed = FALSE)

print("NETWORKS CREATED")
print("===============")
print(sprintf("Pre-election: %d nodes, %d edges", 
              snafun::count_vertices(g_pre_viz), snafun::count_edges(g_pre_viz)))
print(sprintf("Post-formation: %d nodes, %d edges", 
              snafun::count_vertices(g_post_viz), snafun::count_edges(g_post_viz)))

# Add ideology attributes for visualization (matching reference script)
add_ideology_for_visualization <- function(g, ideology_data) {
  party_names <- igraph::V(g)$name
  
  # Add left_right and conservative_progressive
  left_right_vals <- sapply(party_names, function(p) {
    idx <- which(ideology_data$party == p)
    if(length(idx) > 0) ideology_data$left_right[idx[1]] else NA
  })
  igraph::V(g)$left_right <- left_right_vals
  
  conservative_progressive_vals <- sapply(party_names, function(p) {
    idx <- which(ideology_data$party == p)
    if(length(idx) > 0) ideology_data$conservative_progressive[idx[1]] else NA
  })
  igraph::V(g)$conservative_progressive <- conservative_progressive_vals
  
  # Party categories for coloring (matching reference script)
  # Left: negative values (< -0.2)
  # Center: close to 0 (-0.2 to 0.2)
  # Right: positive values (> 0.2)
  party_type <- ifelse(
    party_names %in% c("BIJ1", "PvdD", "GroenLinks", "PvdA", "GroenLinks-PvdA", "DENK", "SP", "ChristenUnie", "50PLUS"), "Left",
    ifelse(party_names %in% c("Volt", "D66", "NSC", "BBB"), "Center", "Right")
  )
  igraph::V(g)$party_type <- party_type
  
  # Ideology for layout (matching reference script)
  ideology_pos <- ifelse(
    party_names %in% c("BIJ1", "PvdD", "GroenLinks", "PvdA", "GroenLinks-PvdA", "DENK", "SP"), 1,
    ifelse(party_names %in% c("ChristenUnie", "50PLUS", "Volt", "D66", "NSC", "Omtzigt"), 2,
    ifelse(party_names %in% c("BBB", "PVV", "CDA"), 3,
    ifelse(party_names %in% c("VVD", "SGP"), 4, 5)))
  )
  igraph::V(g)$ideology <- ideology_pos
  
  return(g)
}

# Add ideology attributes to networks for visualization
g_pre_viz <- add_ideology_for_visualization(g_pre_viz, ideology_data)
g_post_viz <- add_ideology_for_visualization(g_post_viz, ideology_data)

# Create ideology-based layout
party_colors <- c("Left" = "#E74C3C", "Center" = "#F39C12", "Right" = "#3498DB")

set.seed(42)  # Same seed for reproducibility
layout_coords <- matrix(0, nrow = nrow(nodelist), ncol = 2)
for(i in seq_len(nrow(nodelist))) {
  party <- nodelist$name[i]
  if(party %in% igraph::V(g_pre_viz)$name) {
    ideology_pos <- igraph::V(g_pre_viz)$ideology[igraph::V(g_pre_viz)$name == party][1]
  } else if(party %in% igraph::V(g_post_viz)$name) {
    ideology_pos <- igraph::V(g_post_viz)$ideology[igraph::V(g_post_viz)$name == party][1]
  } else {
    ideology_pos <- 3
  }
  layout_coords[i, 1] <- ideology_pos + stats::runif(1, -0.3, 0.3)
  layout_coords[i, 2] <- stats::runif(1, -1, 1)
}

# Visualization function
visualize_network_raw <- function(g, title, layout_coords, party_names) {
  # Color and size nodes (matching reference)
  igraph::V(g)$color <- party_colors[igraph::V(g)$party_type]
  igraph::V(g)$size <- pmax(8, sqrt(igraph::degree(g)) * 4)
  
  # Edge styling for raw networks
  if(snafun::count_edges(g) > 0) {
    # Use raw weights for visualization
    igraph::E(g)$width <- pmax(0.5, (igraph::E(g)$weight / max(igraph::E(g)$weight)) * 3)
    mean_raw <- mean(igraph::E(g)$weight)
    threshold <- mean_raw * 1.3
    igraph::E(g)$color <- ifelse(igraph::E(g)$weight >= threshold,
                                 grDevices::rgb(0.3, 0.3, 0.3, 0.8),
                                 grDevices::rgb(0.5, 0.5, 0.5, 0.15))
  }
  
  # Match layout to party order
  layout_match <- layout_coords[match(igraph::V(g)$name, party_names), ]
  
  plot(g, layout = layout_match,
       vertex.label.cex = 0.7,
       vertex.label.color = "black",
       vertex.frame.color = "white",
       main = title)
}

# Visualize networks
par(mfrow = c(1, 2), mar = c(2, 2, 4, 2))
visualize_network_raw(g_pre_viz, "PRE-ELECTION\n(Nov 22, 2022 - Nov 21, 2023)", 
                      layout_coords, nodelist$name)
visualize_network_raw(g_post_viz, "POST-FORMATION\n(Jul 5, 2024 - Jul 4, 2025)", 
                      layout_coords, nodelist$name)
```

## 2.4 Edge Weight Statistics

```{r edge-weight-stats}
# Compare raw weights between periods
print("EDGE WEIGHT STATISTICS")
print("======================")
print("")
print("RAW WEIGHT COMPARISON:")
print(sprintf("Pre-election: Mean = %.1f, SD = %.1f, Range = [%.0f, %.0f]",
              mean(edgelist_pre$weight), sd(edgelist_pre$weight),
              min(edgelist_pre$weight), max(edgelist_pre$weight)))
print(sprintf("Post-formation: Mean = %.1f, SD = %.1f, Range = [%.0f, %.0f]",
              mean(edgelist_post$weight), sd(edgelist_post$weight),
              min(edgelist_post$weight), max(edgelist_post$weight)))
```

## 2.5 Co-Sponsorship Exploration

Co-sponsorship edge lists are now pre-generated by the Python script and loaded from CSV files.

```{r cosponsorship-exploration}
# Load pre-generated co-sponsorship edge lists
edgelist_cosponsor_pre <- read.csv("results/edge_lists/cosponsor_pre_election.csv", stringsAsFactors = FALSE)
edgelist_cosponsor_post <- read.csv("results/edge_lists/cosponsor_post_formation.csv", stringsAsFactors = FALSE)
  
  print("CO-SPONSORSHIP EXPLORATION")
  print("===========================")
print("Co-sponsorship edge lists generated by generate_edgelists.py")
  print("")
  
  # Pre-election analysis
  print("PRE-ELECTION:")
  print(sprintf("  Total co-sponsorship pairs: %d", nrow(edgelist_cosponsor_pre)))
  if(nrow(edgelist_cosponsor_pre) > 0) {
    print(sprintf("  Mean co-sponsorships per pair: %.1f", mean(edgelist_cosponsor_pre$weight)))
    print(sprintf("  Max co-sponsorships: %.0f", max(edgelist_cosponsor_pre$weight)))
} else {
  print("  No co-sponsorship relationships found in pre-election period")
  }
  
  print("")
  print("POST-FORMATION:")
  print(sprintf("  Total co-sponsorship pairs: %d", nrow(edgelist_cosponsor_post)))
  if(nrow(edgelist_cosponsor_post) > 0) {
    print(sprintf("  Mean co-sponsorships per pair: %.1f", mean(edgelist_cosponsor_post$weight)))
    print(sprintf("  Max co-sponsorships: %.0f", max(edgelist_cosponsor_post$weight)))
} else {
  print("  No co-sponsorship relationships found in post-formation period")
}
```

## 2.6 Coalition Exploration

```{r coalition-exploration}
# Load pre-generated coalition edge list
coalition_edgelist_filtered <- read.csv("results/edge_lists/coalition_edges.csv", stringsAsFactors = FALSE)

print("COALITION EXPLORATION")
print("=====================")
print("Coalition edge list generated by generate_edgelists.py")
print(sprintf("Total coalition edges: %d", nrow(coalition_edgelist_filtered)))
if(nrow(coalition_edgelist_filtered) > 0) {
  print(sprintf("Mean coalition count: %.1f", mean(coalition_edgelist_filtered$weight)))
  print(sprintf("Max coalition count: %.0f", max(coalition_edgelist_filtered$weight)))
  
  # Top coalition pairs
  coalition_sorted <- coalition_edgelist_filtered[order(-coalition_edgelist_filtered$weight), ]
  print("")
  print("Top 5 coalition pairs:")
  for(i in seq_len(min(5, nrow(coalition_sorted)))) {
    print(sprintf("  %d. %s - %s: %d times", i, coalition_sorted$from[i], 
                  coalition_sorted$to[i], coalition_sorted$weight[i]))
  }
}
```

## 2.7 Threshold Analysis for Network Binarization

```{r threshold-analysis}
print("THRESHOLD ANALYSIS FOR NETWORK BINARIZATION")
print("===========================================")
print("")

# Get edge weights from both networks (exclude the 1e-6 fill values)
weights_pre <- igraph::E(g_pre)$weight[igraph::E(g_pre)$weight > 1e-6]
weights_post <- igraph::E(g_post)$weight[igraph::E(g_post)$weight > 1e-6]

print("EDGE WEIGHT DISTRIBUTIONS:")
print("==========================")
print("Pre-election (original edges only):")
print(sprintf("  Count: %d edges", length(weights_pre)))
print(sprintf("  Mean: %.2f", mean(weights_pre)))
print(sprintf("  Median: %.2f", median(weights_pre)))
print(sprintf("  SD: %.2f", sd(weights_pre)))
print(sprintf("  Min: %.0f", min(weights_pre)))
print(sprintf("  Max: %.0f", max(weights_pre)))
print("  Quantiles:")
quantiles_pre <- quantile(weights_pre, c(0.25, 0.5, 0.75, 0.9, 0.95))
for(i in seq_along(quantiles_pre)) {
  print(sprintf("    %s: %.1f", names(quantiles_pre)[i], quantiles_pre[i]))
}

print("")
print("Post-formation (original edges only):")
print(sprintf("  Count: %d edges", length(weights_post)))
print(sprintf("  Mean: %.2f", mean(weights_post)))
print(sprintf("  Median: %.2f", median(weights_post)))
print(sprintf("  SD: %.2f", sd(weights_post)))
print(sprintf("  Min: %.0f", min(weights_post)))
print(sprintf("  Max: %.0f", max(weights_post)))
print("  Quantiles:")
quantiles_post <- quantile(weights_post, c(0.25, 0.5, 0.75, 0.9, 0.95))
for(i in seq_along(quantiles_post)) {
  print(sprintf("    %s: %.1f", names(quantiles_post)[i], quantiles_post[i]))
}

# Calculate potential thresholds
thresholds <- list(
  mean_pre = mean(weights_pre),
  median_pre = median(weights_pre),
  q75_pre = quantile(weights_pre, 0.75),
  q90_pre = quantile(weights_pre, 0.90),
  mean_plus_sd_pre = mean(weights_pre) + sd(weights_pre),
  mean_post = mean(weights_post),
  median_post = median(weights_post),
  q75_post = quantile(weights_post, 0.75),
  q90_post = quantile(weights_post, 0.90),
  mean_plus_sd_post = mean(weights_post) + sd(weights_post),
  overall_mean = mean(c(weights_pre, weights_post)),
  overall_median = median(c(weights_pre, weights_post))
)

print("")
print("POTENTIAL THRESHOLDS:")
print("=====================")
for(name in names(thresholds)) {
  threshold_val <- thresholds[[name]]
  
  # Count edges that would remain
  edges_pre_remain <- sum(weights_pre >= threshold_val)
  edges_post_remain <- sum(weights_post >= threshold_val)
  
  # Percentage of original edges retained
  pct_pre <- (edges_pre_remain / length(weights_pre)) * 100
  pct_post <- (edges_post_remain / length(weights_post)) * 100
  
  print(sprintf("%s: %.1f", name, threshold_val))
  print(sprintf("  → Pre: %d/%d edges (%.1f%%)", edges_pre_remain, length(weights_pre), pct_pre))
  print(sprintf("  → Post: %d/%d edges (%.1f%%)", edges_post_remain, length(weights_post), pct_post))
}

# Distribution plots
print("")
print("EDGE WEIGHT DISTRIBUTIONS (plots):")
par(mfrow = c(2, 2), mar = c(4, 4, 3, 2))

# Histograms
hist(weights_pre, breaks = 20, main = "Pre-Election Edge Weights", 
     xlab = "Weight", col = "#E74C3C", alpha = 0.7)
abline(v = mean(weights_pre), col = "blue", lwd = 2, lty = 2)
abline(v = median(weights_pre), col = "darkgreen", lwd = 2, lty = 2)
legend("topright", c("Mean", "Median"), col = c("blue", "darkgreen"), lty = 2)

hist(weights_post, breaks = 20, main = "Post-Formation Edge Weights", 
     xlab = "Weight", col = "#3498DB", alpha = 0.7)
abline(v = mean(weights_post), col = "blue", lwd = 2, lty = 2)
abline(v = median(weights_post), col = "darkgreen", lwd = 2, lty = 2)
legend("topright", c("Mean", "Median"), col = c("blue", "darkgreen"), lty = 2)

# Boxplots for comparison
boxplot(list("Pre-Election" = weights_pre, "Post-Formation" = weights_post),
        main = "Edge Weight Comparison", ylab = "Weight", 
        col = c("#E74C3C", "#3498DB"))

# Density comparison
plot(density(weights_pre), main = "Edge Weight Densities", 
     xlab = "Weight", ylab = "Density", col = "#E74C3C", lwd = 2)
lines(density(weights_post), col = "#3498DB", lwd = 2)
legend("topright", c("Pre-Election", "Post-Formation"), 
       col = c("#E74C3C", "#3498DB"), lwd = 2)

# Network density analysis at different thresholds
print("")
print("NETWORK DENSITY AT DIFFERENT THRESHOLDS:")
print("========================================")

test_thresholds <- c(
  quantile(c(weights_pre, weights_post), 0.5),   # Overall median
  quantile(c(weights_pre, weights_post), 0.75),  # Overall 75th percentile
  quantile(c(weights_pre, weights_post), 0.9),   # Overall 90th percentile
  mean(c(weights_pre, weights_post))             # Overall mean
)

names(test_thresholds) <- c("Overall_Median", "Overall_75th", "Overall_90th", "Overall_Mean")

for(i in seq_along(test_thresholds)) {
  threshold_name <- names(test_thresholds)[i]
  threshold_val <- test_thresholds[i]
  
  # Create binary adjacency matrices
  adj_binary_pre <- ifelse(adj_matrix_pre > threshold_val, 1, 0)
  adj_binary_post <- ifelse(adj_matrix_post > threshold_val, 1, 0)
  diag(adj_binary_pre) <- 0
  diag(adj_binary_post) <- 0
  
  # Create binary networks
  g_binary_pre <- igraph::graph_from_adjacency_matrix(adj_binary_pre, mode = "undirected")
  g_binary_post <- igraph::graph_from_adjacency_matrix(adj_binary_post, mode = "undirected")
  
  # Calculate network statistics
  density_pre <- snafun::g_density(g_binary_pre)
  density_post <- snafun::g_density(g_binary_post)
  edges_pre <- snafun::count_edges(g_binary_pre)
  edges_post <- snafun::count_edges(g_binary_post)
  
  print(sprintf("%s (threshold = %.1f):", threshold_name, threshold_val))
  print(sprintf("  Pre-election:  %d edges, density = %.4f", edges_pre, density_pre))
  print(sprintf("  Post-formation: %d edges, density = %.4f", edges_post, density_post))
}

print("")
print("RECOMMENDED THRESHOLDS:")
print("=======================")
print("• Overall_Median: Balanced approach, retains ~50% of strongest connections")
print("• Overall_75th: Conservative approach, focuses on strongest connections") 
print("• Overall_Mean: Moderate approach, good balance of edges vs. sparsity")
print("• Consider network density: aim for 0.1-0.3 for ERGM stability")
```

------------------------------------------------------------------------

# 3. Study 1 Preprocessing (QAP)

## 3.1 Use Fully Connected Networks

Study 1 compares network structures between pre-election and post-formation periods using QAP (Quadratic Assignment Procedure). We use the fully connected networks created in general preprocessing.

```{r study1-networks}
# Study 1 uses the fully connected networks from general preprocessing
g_study1_pre_connected <- g_pre_connected
g_study1_post_connected <- g_post_connected

print("STUDY 1: USING FULLY CONNECTED NETWORKS")
print("========================================")
print(sprintf("Pre-election: %d nodes, fully connected", 
              snafun::count_vertices(g_study1_pre_connected)))
print(sprintf("Post-formation: %d nodes, fully connected", 
              snafun::count_vertices(g_study1_post_connected)))
print("Networks ready for QAP analysis")
```

------------------------------------------------------------------------

# 4. Study 2 Preprocessing (ERGM)

## 4.1 Network Binarization for ERGM

Study 2 uses ERGM (Exponential Random Graph Model) to model network formation with covariates. ERGM requires binary networks, so we binarize using period-specific 70th percentile thresholds to balance network density with transitivity term identifiability.

```{r study2-binarization}
# Calculate period-specific 70th percentile thresholds (balanced for transitivity modeling)
weights_pre <- igraph::E(g_pre)$weight[igraph::E(g_pre)$weight > 1e-6]
weights_post <- igraph::E(g_post)$weight[igraph::E(g_post)$weight > 1e-6]

threshold_pre <- quantile(weights_pre, 0.70)
threshold_post <- quantile(weights_post, 0.70)

print("STUDY 2: NETWORK BINARIZATION")
print("==============================")
print(sprintf("Pre-election threshold (70th percentile): %.1f", threshold_pre))
print(sprintf("Post-formation threshold (70th percentile): %.1f", threshold_post))

# Create binary adjacency matrices using period-specific thresholds
adj_binary_pre <- ifelse(adj_matrix_pre > threshold_pre, 1, 0)
adj_binary_post <- ifelse(adj_matrix_post > threshold_post, 1, 0)
diag(adj_binary_pre) <- 0
diag(adj_binary_post) <- 0

# Create binary igraph networks
g_study2_pre_binary <- igraph::graph_from_adjacency_matrix(adj_binary_pre, 
                                                           mode = "undirected")
g_study2_post_binary <- igraph::graph_from_adjacency_matrix(adj_binary_post, 
                                                            mode = "undirected")

# Add vertex names from nodelist
igraph::V(g_study2_pre_binary)$name <- nodelist$name
igraph::V(g_study2_post_binary)$name <- nodelist$name

# Add ideology attributes from nodelist
igraph::V(g_study2_pre_binary)$left_right <- nodelist$left_right
igraph::V(g_study2_post_binary)$left_right <- nodelist$left_right

print("")
print("BINARY NETWORKS CREATED:")
print(sprintf("Pre-election: %d nodes, %d edges, density = %.4f", 
              snafun::count_vertices(g_study2_pre_binary), 
              snafun::count_edges(g_study2_pre_binary),
              snafun::g_density(g_study2_pre_binary)))
print(sprintf("Post-formation: %d nodes, %d edges, density = %.4f", 
              snafun::count_vertices(g_study2_post_binary), 
              snafun::count_edges(g_study2_post_binary),
              snafun::g_density(g_study2_post_binary)))
print("Left-right ideology attributes added to vertices")
```

## 4.2 Prepare Edge Covariate Matrices for ERGM

For ERGM analysis, edge covariates are provided as matrices rather than network attributes. We create matrices from the co-sponsorship and coalition edge lists.

```{r study2-edge-covariates}
# Function to create edge covariate matrix from edgelist
create_edge_covariate_matrix <- function(edgelist_attribute, party_names) {
  # Initialize matrix with zeros
  n_parties <- length(party_names)
  covariate_matrix <- matrix(0, nrow = n_parties, ncol = n_parties)
  rownames(covariate_matrix) <- party_names
  colnames(covariate_matrix) <- party_names
  
  # Fill in values from edgelist
  if(nrow(edgelist_attribute) > 0) {
    for(i in seq_len(nrow(edgelist_attribute))) {
      from_party <- edgelist_attribute$from[i]
      to_party <- edgelist_attribute$to[i]
      weight <- edgelist_attribute$weight[i]
      
      # Add to both directions (undirected)
      if(from_party %in% party_names && to_party %in% party_names) {
        covariate_matrix[from_party, to_party] <- weight
        covariate_matrix[to_party, from_party] <- weight
      }
    }
  }
  
  # Ensure diagonal is 0
  diag(covariate_matrix) <- 0
  
  return(covariate_matrix)
}

# Load pre-generated filtered edge lists for Study 2
edgelist_cosponsor_pre_filtered <- read.csv("results/edge_lists/study2_cosponsor_pre_election.csv", stringsAsFactors = FALSE)
edgelist_cosponsor_post_filtered <- read.csv("results/edge_lists/study2_cosponsor_post_formation.csv", stringsAsFactors = FALSE)
coalition_edgelist_pre_filtered <- read.csv("results/edge_lists/study2_coalition_filtered.csv", stringsAsFactors = FALSE)
coalition_edgelist_post_filtered <- read.csv("results/edge_lists/study2_coalition_filtered.csv", stringsAsFactors = FALSE)

# Get party names in correct order
party_names <- igraph::V(g_study2_pre_binary)$name

# Create edge covariate matrices
cosponsor_matrix_pre <- create_edge_covariate_matrix(edgelist_cosponsor_pre_filtered, party_names)
cosponsor_matrix_post <- create_edge_covariate_matrix(edgelist_cosponsor_post_filtered, party_names)
coalition_matrix_pre <- create_edge_covariate_matrix(coalition_edgelist_pre_filtered, party_names)
coalition_matrix_post <- create_edge_covariate_matrix(coalition_edgelist_post_filtered, party_names)

print("STUDY 2: EDGE COVARIATE MATRICES CREATED")
print("=========================================")
print("Pre-election:")
print(sprintf("  Co-sponsorship matrix: %d x %d, %d non-zero entries", 
              nrow(cosponsor_matrix_pre), ncol(cosponsor_matrix_pre),
              sum(cosponsor_matrix_pre > 0)))
print(sprintf("  Coalition matrix: %d x %d, %d non-zero entries", 
              nrow(coalition_matrix_pre), ncol(coalition_matrix_pre),
              sum(coalition_matrix_pre > 0)))
print("")
print("Post-formation:")
print(sprintf("  Co-sponsorship matrix: %d x %d, %d non-zero entries", 
              nrow(cosponsor_matrix_post), ncol(cosponsor_matrix_post),
              sum(cosponsor_matrix_post > 0)))
print(sprintf("  Coalition matrix: %d x %d, %d non-zero entries", 
              nrow(coalition_matrix_post), ncol(coalition_matrix_post),
              sum(coalition_matrix_post > 0)))
print("")
print("Networks ready for ERGM analysis with:")
print("  • Binary adjacency matrices (dependent variables)")
print("  • Left-right ideology (vertex attribute)")  
print("  • Co-sponsorship and coalition matrices (edge covariates)")
```

------------------------------------------------------------------------

# 5. QAP Analysis (Study 1)

## 5.1 Overview

QAP (Quadratic Assignment Procedure) is used in Study 1 to test whether the network structure changed significantly between the pre-election and post-formation periods. QAP compares two networks by:

1. Computing a test statistic (e.g., correlation) between the two adjacency matrices
2. Permuting rows and columns of one matrix to generate a null distribution
3. Comparing the observed statistic to the null distribution to assess significance

## 5.2 Prepare Data for QAP

```{r qap-prepare}
# Load required packages
if(!require(sna)) install.packages("sna")
library(sna)

# Create results directory if it doesn't exist
if(!dir.exists("results/statistics")) {
  dir.create("results/statistics", recursive = TRUE)
}

# Ensure matrices are properly aligned (same row/column order)
# Both matrices should already have the same party order from Study 1 preprocessing
party_order <- rownames(adj_matrix_pre)

# Verify alignment
if(!all(rownames(adj_matrix_pre) == rownames(adj_matrix_post)) ||
   !all(colnames(adj_matrix_pre) == colnames(adj_matrix_post))) {
  stop("Adjacency matrices are not aligned!")
}

print("QAP DATA PREPARATION")
print("====================")
print(sprintf("Pre-election matrix: %d x %d", nrow(adj_matrix_pre), ncol(adj_matrix_pre)))
print(sprintf("Post-formation matrix: %d x %d", nrow(adj_matrix_post), ncol(adj_matrix_post)))
print(sprintf("Number of parties: %d", length(party_order)))
print("Matrices are aligned and ready for QAP analysis")
```

## 5.3 Network-Level Metrics Comparison

```{r qap-metrics}
# Calculate network-level metrics for comparison
# Using snafun for basic metrics and base R/igraph for others

# Pre-election metrics
g_pre <- g_study1_pre_connected
g_post <- g_study1_post_connected

metrics_pre <- list(
  vertices = snafun::count_vertices(g_pre),
  edges = snafun::count_edges(g_pre),
  density = snafun::g_density(g_pre),
  mean_degree = mean(igraph::degree(g_pre)),
  mean_weight = mean(igraph::E(g_pre)$weight),
  max_weight = max(igraph::E(g_pre)$weight),
  min_weight = min(igraph::E(g_pre)$weight)
)

metrics_post <- list(
  vertices = snafun::count_vertices(g_post),
  edges = snafun::count_edges(g_post),
  density = snafun::g_density(g_post),
  mean_degree = mean(igraph::degree(g_post)),
  mean_weight = mean(igraph::E(g_post)$weight),
  max_weight = max(igraph::E(g_post)$weight),
  min_weight = min(igraph::E(g_post)$weight)
)

# Create comparison table
metrics_comparison <- data.frame(
  Metric = c("Vertices", "Edges", "Density", "Mean Degree", 
             "Mean Weight", "Max Weight", "Min Weight"),
  Pre_Election = c(
    metrics_pre$vertices,
    metrics_pre$edges,
    sprintf("%.4f", metrics_pre$density),
    sprintf("%.2f", metrics_pre$mean_degree),
    sprintf("%.4f", metrics_pre$mean_weight),
    sprintf("%.4f", metrics_pre$max_weight),
    sprintf("%.4f", metrics_pre$min_weight)
  ),
  Post_Formation = c(
    metrics_post$vertices,
    metrics_post$edges,
    sprintf("%.4f", metrics_post$density),
    sprintf("%.2f", metrics_post$mean_degree),
    sprintf("%.4f", metrics_post$mean_weight),
    sprintf("%.4f", metrics_post$max_weight),
    sprintf("%.4f", metrics_post$min_weight)
  ),
  stringsAsFactors = FALSE
)

print("NETWORK-LEVEL METRICS COMPARISON")
print("=================================")
print(metrics_comparison)
```

## 5.4 QAP Correlation Test

```{r qap-correlation}
# Perform QAP correlation test using matrices directly
# This tests whether the correlation between the two networks is significant
# H1.1: Dutch political parties show different levels of voting agreement 
#       before elections compared to after cabinet formation
# Note: Warnings about "standard deviation is zero" during permutations are 
#       typically harmless and occur when some permuted rows/columns are constant
set.seed(12345)

# Compute observed correlation
observed_corr <- sna::gcor(adj_matrix_pre, adj_matrix_post)
print(sprintf("Observed correlation: %.4f", observed_corr))

# Perform QAP test using matrices directly (sna::gcor works with matrices)
suppressWarnings({
  qap_result <- sna::qaptest(
    list(adj_matrix_pre, adj_matrix_post),
    FUN = sna::gcor,
    reps = 1000,
    g1 = 1,
    g2 = 2
  )
})

print("QAP CORRELATION TEST")
print("====================")
print(sprintf("Observed correlation: %.4f", qap_result$testval))
print(sprintf("Number of permutations: %d", qap_result$reps))
print("")
print("QAP Test Summary:")
print(summary(qap_result))
print("")
print("QAP Test Plot:")
plot(qap_result)
```

## 5.5 QAP Results Interpretation

```{r qap-interpretation}
# Extract p-value and interpret results
p_value <- mean(qap_result$dist >= qap_result$testval)

print("QAP RESULTS INTERPRETATION")
print("===========================")
print(sprintf("Observed correlation: %.4f", qap_result$testval))
print(sprintf("P-value (one-tailed): %.4f", p_value))
print(sprintf("P-value (two-tailed): %.4f", 2 * min(p_value, 1 - p_value)))
print("")
if(p_value < 0.05) {
  print("Interpretation: The correlation between pre-election and post-formation")
  print("networks is statistically significant (p < 0.05).")
  print("The network structures are significantly similar.")
} else {
  print("Interpretation: The correlation between pre-election and post-formation")
  print("networks is NOT statistically significant (p >= 0.05).")
  print("The network structures differ significantly between periods.")
}

# Save QAP results
qap_summary <- list(
  observed_correlation = qap_result$testval,
  p_value_one_tailed = p_value,
  p_value_two_tailed = 2 * min(p_value, 1 - p_value),
  n_permutations = qap_result$reps,
  interpretation = ifelse(p_value < 0.05, 
                         "Networks are significantly similar",
                         "Networks differ significantly")
)

# Export results
save(qap_result, qap_summary, metrics_comparison,
     file = "results/statistics/qap_results.RData")
print("")
print("QAP results saved to results/statistics/qap_results.RData")
```

------------------------------------------------------------------------

# 6. ERGM Setup

## 6.1 Overview

ERGM (Exponential Random Graph Model) will be used in Study 2 to model binary network formation with covariates. ERGM allows us to test hypotheses about which factors influence the presence/absence of strong cooperation ties between parties.

## 6.2 Hypotheses and Model Terms

The ERGM will test the following hypotheses using binary networks (70th percentile threshold):

-   **H2.1**: Parties with similar ideologies on the left-right spectrum are more likely to have strong cooperation ties.
    -   *Term*: `absdiff("left_right")` - measures how differences in ideology impact tie formation
-   **H2.2**: Parties that have often been in a coalition together are more likely to have strong cooperation ties.
    -   *Term*: `edgecov(coalition_matrix)` - uses coalition count as edge covariate
-   **H2.3**: Parties are more likely to cooperate if they share cooperation with a third party (transitivity).
    -   *Term*: `gwesp(0.1, fixed=TRUE)` - captures geometrically weighted edgewise shared partners (very low decay for transitivity testing)
-   **H2.4**: Some parties are more likely to cooperate with many other parties (degree effects).
    -   *Term*: `kstar(3)` - captures tendency for some parties to form broader cooperation patterns (3-star configurations)
-   **H2.5**: Parties who frequently co-sponsor motions tend to have stronger cooperation ties.
    -   *Term*: `edgecov(cosponsor_matrix)` - uses co-sponsorship count as edge covariate

## 6.3 Pre-Election ERGM Specification and Estimation

```{r eval=FALSE}

# Create results directory if it doesn't exist
if(!dir.exists("results/models")) {
  dir.create("results/models", recursive = TRUE)
}

print("PRE-ELECTION ERGM ESTIMATION")
print("=============================")

# Convert binary igraph to network object for ergm
net_pre_binary <- network::as.network(
  igraph::as_adjacency_matrix(g_study2_pre_binary, sparse = FALSE),
  directed = FALSE
)

# Add vertex attributes
network::set.vertex.attribute(net_pre_binary, "left_right", 
                              igraph::V(g_study2_pre_binary)$left_right)

# Full ERGM model specification (tests all 5 hypotheses)
formula_pre <- net_pre_binary ~ 
  edges +                               # Baseline density
  absdiff("left_right") +              # H2.1: Ideology homophily
  gwesp(0.1, fixed = TRUE) +           # H2.3: Transitivity 
  kstar(3) +                           # H2.4: Degree popularity
  edgecov(cosponsor_matrix_pre) +      # H2.5: Co-sponsorship effects
  edgecov(coalition_matrix_pre)        # H2.2: Coalition history

# Estimate ERGM
set.seed(1234)

ergm_pre <- ergm::ergm(
  formula_pre,
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    seed = 1234,
    MCMC.interval = 1500,
    MCMC.prop = ~sparse + .triadic
  )
)

# Results
print("PRE-ELECTION ERGM RESULTS:")
print("==========================")
summary(ergm_pre)

# Goodness of fit
gof_pre <- ergm::gof(ergm_pre)
print(gof_pre)
plot(gof_pre)

# Save results
saveRDS(ergm_pre, file = "results/models/ergm_pre_election.rds")
print("Pre-election ERGM saved to results/models/ergm_pre_election.rds")
```

## 6.4 Post-Formation ERGM Specification and Estimation

```{r eval=FALSE}
print("POST-FORMATION ERGM ESTIMATION")
print("===============================")

# Convert binary igraph to network object for ergm
net_post_binary <- network::as.network(
  igraph::as_adjacency_matrix(g_study2_post_binary, sparse = FALSE),
  directed = FALSE
)

# Add vertex attributes
network::set.vertex.attribute(net_post_binary, "left_right", 
                              igraph::V(g_study2_post_binary)$left_right)

# Full ERGM model specification (same as pre-election for comparison)
formula_post <- net_post_binary ~ 
  edges +                               # Baseline density
  absdiff("left_right") +              # H2.1: Ideology homophily
  gwesp(0.1, fixed = TRUE) +           # H2.3: Transitivity
  kstar(3) +                           # H2.4: Degree popularity
  edgecov(cosponsor_matrix_post) +     # H2.5: Co-sponsorship effects
  edgecov(coalition_matrix_post)       # H2.2: Coalition history

# Estimate ERGM
set.seed(1234)
ergm_post <- ergm::ergm(
  formula_post,
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    seed = 1234,
    MCMC.interval = 1500,
    MCMC.prop = ~sparse + .triadic
  )
)

# Results  
print("POST-FORMATION ERGM RESULTS:")
print("=============================")
summary(ergm_post)

# Goodness of fit
gof_post <- ergm::gof(ergm_post)
print(gof_post)
plot(gof_post)

# Save results
saveRDS(ergm_post, file = "results/models/ergm_post_formation.rds")
print("Post-formation ERGM saved to results/models/ergm_post_formation.rds")
```

# 7. Summary

## 7.1 Preprocessing Summary

```{r summary}
print("PREPROCESSING SUMMARY")
print("====================")
print("")
print("DATA PREPARATION:")
print(sprintf("  • Pre-election: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_pre), big.mark = ","),
              format(length(unique(motion_data_pre$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_pre$ActorFractie))))
print(sprintf("  • Post-formation: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_post), big.mark = ","),
              format(length(unique(motion_data_post$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_post$ActorFractie))))
print("")
print("FULLY CONNECTED NETWORKS (GENERAL PREPROCESSING):")
print(sprintf("  • Pre-election: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_pre_connected), snafun::count_edges(g_pre_connected)))
print(sprintf("  • Post-formation: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_post_connected), snafun::count_edges(g_post_connected)))
print("  • All zero edge weights set to 1e-6 for full connectivity")
print("  • Adjacency matrices exported")
print("")
print("STUDY 1 (QAP):")
print("  • Uses fully connected networks from general preprocessing")
print("  • Ready for QAP correlation test")
print("")
print("STUDY 2 (ERGM):")
print(sprintf("  • Pre-election: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_pre), snafun::count_edges(g_study2_pre)))
print(sprintf("  • Post-formation: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_post), snafun::count_edges(g_study2_post)))
print("  • Same node set for comparability between periods")
print("  • Ideology, co-sponsorship, and coalition attributes added")
print("  • Ready for ERGM analysis")
```

## 7.2 Files Generated

All preprocessing outputs have been saved to:

-   **Adjacency Matrices:** `results/adjacency_matrices/`
    -   `pre_election_adjacency.csv`
    -   `post_formation_adjacency.csv`
-   **Statistics:** `results/statistics/`
-   **Visualizations:** `results/visualizations/`

------------------------------------------------------------------------

# Session Info

```{r session-info}
sessionInfo()
```
