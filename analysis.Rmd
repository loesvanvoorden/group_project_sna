---
title: "Electoral Cycle Network Analysis: Dutch Parliament 2023-2024"
subtitle: "Pre-Election vs. Post-Formation Party Cooperation Networks"
author: "Your Name"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: show
    theme: flatly
    highlight: tango
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  results = 'asis',
  fig.width = 12,
  fig.height = 8,
  fig.path = "results/visualizations/"
)
print(paste("Working directory set to:", getwd()))
```

------------------------------------------------------------------------

# 1. Data Preparation

## 1.1 Load Data

```{r load-data}
# Load voting data
voting_data_2023 <- read.csv("data/voting_data_2023_preelection.csv", stringsAsFactors = FALSE)
voting_data_2024 <- read.csv("data/voting_data_clean.csv", stringsAsFactors = FALSE)

# Convert dates
voting_data_2023$date <- lubridate::ymd_hms(voting_data_2023$GewijzigdOp)
voting_data_2024$date <- lubridate::ymd_hms(voting_data_2024$GewijzigdOp)

# Load Kieskompas ideology data
ideology_data <- read.csv("data/political_axes_data.csv", stringsAsFactors = FALSE)
names(ideology_data) <- c("left_right", "conservative_progressive", "party")
ideology_data <- ideology_data[!is.na(ideology_data$party) & ideology_data$party != "", ]

print("Data loaded:")
print(sprintf("  • 2023 records: %s", format(nrow(voting_data_2023), big.mark = ",")))
print(sprintf("  • 2024 records: %s", format(nrow(voting_data_2024), big.mark = ",")))
print(sprintf("  • Ideology data: %d parties", nrow(ideology_data)))
```

## 1.2 General Preprocessing: Extract Motion Datasets

```{r general-preprocessing}
# Key dates
election_date <- lubridate::ymd("2023-11-22")
formation_date <- lubridate::ymd("2024-07-05")

# Extract motion dataset 1 year BEFORE election (Nov 22, 2022 - Nov 21, 2023)
pre_election_start <- election_date - lubridate::years(1)
pre_election_end <- election_date - lubridate::days(1)
motion_data_pre <- voting_data_2023[voting_data_2023$date >= pre_election_start & 
                                     voting_data_2023$date <= pre_election_end, ]

# Extract motion dataset 1 year AFTER formation (Jul 5, 2024 - Jul 4, 2025)
post_formation_start <- formation_date
post_formation_end <- formation_date + lubridate::years(1)
motion_data_post <- voting_data_2024[voting_data_2024$date >= post_formation_start & 
                                     voting_data_2024$date <= post_formation_end, ]

# Filter to valid parties (from ideology data)
valid_parties <- ideology_data$party
motion_data_pre <- motion_data_pre[motion_data_pre$ActorFractie %in% valid_parties, ]
motion_data_post <- motion_data_post[motion_data_post$ActorFractie %in% valid_parties, ]

print("GENERAL PREPROCESSING")
print("====================")
print(sprintf("Pre-election: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_pre), big.mark = ","),
              format(length(unique(motion_data_pre$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_pre$ActorFractie))))
print(sprintf("Post-formation: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_post), big.mark = ","),
              format(length(unique(motion_data_post$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_post$ActorFractie))))
```

## 1.3 Load Pre-Generated Edge Lists

Edge lists are now generated by the Python script `generate_edgelists.py` and loaded from CSV files.

```{r load-edgelists}
# Load pre-generated edge lists from Python script
edgelist_pre <- read.csv("results/edge_lists/edges_pre_election.csv", stringsAsFactors = FALSE)
edgelist_post <- read.csv("results/edge_lists/edges_post_formation.csv", stringsAsFactors = FALSE)

print("EDGE LISTS LOADED")
print("=================")
print("Edge lists generated by generate_edgelists.py")
print(sprintf("Pre-election edges: %d", nrow(edgelist_pre)))
print(sprintf("Post-formation edges: %d", nrow(edgelist_post)))
```

## 1.4 Create Fully Connected Networks

Both Study 1 (QAP) and Study 2 (GERGM) require fully connected networks. We create these networks with all parties from the ideology data, setting zero edge weights to 1e-6 for full connectivity.

```{r fully-connected-networks}
# Create nodelist from ideology data (like final_ergm.R approach)
nodelist <- data.frame(
  name = sort(ideology_data$party),
  left_right = ideology_data$left_right[match(sort(ideology_data$party), ideology_data$party)],
  conservative_progressive = ideology_data$conservative_progressive[match(sort(ideology_data$party), ideology_data$party)],
  stringsAsFactors = FALSE
)


# Create igraph networks directly (like final_ergm.R)
g_pre <- igraph::graph_from_data_frame(d = edgelist_pre, vertices = nodelist, directed = FALSE)
g_post <- igraph::graph_from_data_frame(d = edgelist_post, vertices = nodelist, directed = FALSE)

#Remove nodes of parties not present in these elections
#nodes_to_remove_pre <- c("GroenLinks-PvdA","Omtzigt", "NSC", "BIJ1", "BVNL", '50PLUS')
#nodes_to_remove_post <- c("GroenLinks","Omtzigt", "PvdA", "BIJ1", "BVNL", '50PLUS')
#g_pre_cleaned <- snafun::remove_vertices(g_pre,nodes_to_remove)
#g_post_cleaned <- snafun::remove_vertices(g_post,nodes_to_remove)

#generate edge weights and remove 0 for iqr calculation
#edge_weights_pre <- igraph::E(g_pre_cleaned)$weight
#edge_weights_post <- igraph::E(g_post_cleaned)$weight


# Generate adjacency matrices
adj_matrix_pre <- igraph::as_adjacency_matrix(g_pre, attr = "weight", sparse = FALSE)
adj_matrix_post <- igraph::as_adjacency_matrix(g_post, attr = "weight", sparse = FALSE)

# Set 0 values to 1e-6 to make fully connected (but keep diagonal as 0)
adj_matrix_pre[adj_matrix_pre == 0] <- 1e-6
adj_matrix_post[adj_matrix_post == 0] <- 1e-6
diag(adj_matrix_pre) <- 0
diag(adj_matrix_post) <- 0

# Regenerate fully connected networks
g_pre_connected <- igraph::graph_from_adjacency_matrix(adj_matrix_pre, 
                                                       mode = "undirected", 
                                                       weighted = TRUE)
g_post_connected <- igraph::graph_from_adjacency_matrix(adj_matrix_post, 
                                                        mode = "undirected", 
                                                        weighted = TRUE)

# Vertex names are already set from nodelist

print("FULLY CONNECTED NETWORKS CREATED")
print("=================================")
print(sprintf("Pre-election: %d nodes, fully connected (%d edges)", 
              nrow(nodelist), snafun::count_edges(g_pre_connected)))
print(sprintf("Post-formation: %d nodes, fully connected (%d edges)", 
              nrow(nodelist), snafun::count_edges(g_post_connected)))
print("All zero edge weights set to 1e-6 for full connectivity")
print("Networks ready for both Study 1 (QAP) and Study 2 (GERGM)")

# Export adjacency matrices
if(!dir.exists("results/adjacency_matrices")) {
  dir.create("results/adjacency_matrices", recursive = TRUE)
}
write.csv(adj_matrix_pre, "results/adjacency_matrices/pre_election_adjacency.csv", 
          row.names = TRUE)
write.csv(adj_matrix_post, "results/adjacency_matrices/post_formation_adjacency.csv", 
          row.names = TRUE)
print("Adjacency matrices exported")
```

------------------------------------------------------------------------

# 2. Data Exploration

## 2.1 Ideology Correlation

```{r ideology-correlation}
# Pearson correlation between ideology dimensions
pearson_test <- stats::cor.test(ideology_data$left_right, 
                         ideology_data$conservative_progressive, 
                         method = "pearson")

print("IDEOLOGY CORRELATION")
print("====================")
print(sprintf("Pearson r = %.3f (p = %.4f)", pearson_test$estimate, pearson_test$p.value))

# Scatterplot
plot(ideology_data$left_right, ideology_data$conservative_progressive,
     xlab = "Left-Right", ylab = "Conservative-Progressive",
     main = sprintf("Ideology Dimensions (r = %.3f)", pearson_test$estimate),
     pch = 19, col = "steelblue")
abline(lm(conservative_progressive ~ left_right, data = ideology_data), 
       col = "red", lwd = 2)
text(ideology_data$left_right, ideology_data$conservative_progressive, 
     labels = ideology_data$party, pos = 3, cex = 0.7)
```

## 2.2 Vote Unanimity

```{r vote-unanimity}
# Calculate agreement rates per motion
calculate_agreement_rate <- function(data) {
  unique_votes <- data[, c("Besluit_Id", "ActorFractie", "Soort")]
  unique_votes <- unique_votes[!duplicated(unique_votes), ]
  unique_motions <- unique(unique_votes$Besluit_Id)
  
  agreement_rates <- sapply(unique_motions, function(motion_id) {
    motion_votes <- unique_votes[unique_votes$Besluit_Id == motion_id, ]
    voor <- sum(motion_votes$Soort == "Voor")
    tegen <- sum(motion_votes$Soort == "Tegen")
    total <- nrow(motion_votes)
    pmax(voor, tegen) / total
  })
  return(agreement_rates)
}

# Calculate for both periods
agreement_pre <- calculate_agreement_rate(motion_data_pre)
agreement_post <- calculate_agreement_rate(motion_data_post)

print("VOTE UNANIMITY")
print("==============")
print(sprintf("Pre-election: Mean agreement = %.3f", mean(agreement_pre)))
print(sprintf("Post-formation: Mean agreement = %.3f", mean(agreement_post)))

# Comparison boxplot
boxplot(list(Pre = agreement_pre, Post = agreement_post),
        main = "Agreement Rate Comparison",
        ylab = "Agreement Rate", col = c("#E74C3C", "#3498DB"))
```

## 2.3 Network Visualizations

```{r network-visualizations}

# Create networks for visualization (reuse nodelist from earlier)
g_pre_viz <- igraph::graph_from_data_frame(d = edgelist_pre, vertices = nodelist, directed = FALSE)
g_post_viz <- igraph::graph_from_data_frame(d = edgelist_post, vertices = nodelist, directed = FALSE)

print("NETWORKS CREATED")
print("===============")
print(sprintf("Pre-election: %d nodes, %d edges", 
              snafun::count_vertices(g_pre_viz), snafun::count_edges(g_pre_viz)))
print(sprintf("Post-formation: %d nodes, %d edges", 
              snafun::count_vertices(g_post_viz), snafun::count_edges(g_post_viz)))

# Add ideology attributes for visualization (matching reference script)
add_ideology_for_visualization <- function(g, ideology_data) {
  party_names <- igraph::V(g)$name
  
  # Add left_right and conservative_progressive
  left_right_vals <- sapply(party_names, function(p) {
    idx <- which(ideology_data$party == p)
    if(length(idx) > 0) ideology_data$left_right[idx[1]] else NA
  })
  igraph::V(g)$left_right <- left_right_vals
  
  conservative_progressive_vals <- sapply(party_names, function(p) {
    idx <- which(ideology_data$party == p)
    if(length(idx) > 0) ideology_data$conservative_progressive[idx[1]] else NA
  })
  igraph::V(g)$conservative_progressive <- conservative_progressive_vals
  
  # Party categories for coloring (matching reference script)
  # Left: negative values (< -0.2)
  # Center: close to 0 (-0.2 to 0.2)
  # Right: positive values (> 0.2)
  party_type <- ifelse(
    party_names %in% c("BIJ1", "PvdD", "GroenLinks", "PvdA", "GroenLinks-PvdA", "DENK", "SP", "ChristenUnie", "50PLUS"), "Left",
    ifelse(party_names %in% c("Volt", "D66", "NSC", "BBB"), "Center", "Right")
  )
  igraph::V(g)$party_type <- party_type
  
  # Ideology for layout (matching reference script)
  ideology_pos <- ifelse(
    party_names %in% c("BIJ1", "PvdD", "GroenLinks", "PvdA", "GroenLinks-PvdA", "DENK", "SP"), 1,
    ifelse(party_names %in% c("ChristenUnie", "50PLUS", "Volt", "D66", "NSC", "Omtzigt"), 2,
    ifelse(party_names %in% c("BBB", "PVV", "CDA"), 3,
    ifelse(party_names %in% c("VVD", "SGP"), 4, 5)))
  )
  igraph::V(g)$ideology <- ideology_pos
  
  return(g)
}

# Add ideology attributes to networks for visualization
g_pre_viz <- add_ideology_for_visualization(g_pre_viz, ideology_data)
g_post_viz <- add_ideology_for_visualization(g_post_viz, ideology_data)

# Create ideology-based layout
party_colors <- c("Left" = "#E74C3C", "Center" = "#F39C12", "Right" = "#3498DB")

set.seed(42)  # Same seed for reproducibility
layout_coords <- matrix(0, nrow = nrow(nodelist), ncol = 2)
for(i in seq_len(nrow(nodelist))) {
  party <- nodelist$name[i]
  if(party %in% igraph::V(g_pre_viz)$name) {
    ideology_pos <- igraph::V(g_pre_viz)$ideology[igraph::V(g_pre_viz)$name == party][1]
  } else if(party %in% igraph::V(g_post_viz)$name) {
    ideology_pos <- igraph::V(g_post_viz)$ideology[igraph::V(g_post_viz)$name == party][1]
  } else {
    ideology_pos <- 3
  }
  layout_coords[i, 1] <- ideology_pos + stats::runif(1, -0.3, 0.3)
  layout_coords[i, 2] <- stats::runif(1, -1, 1)
}

# Visualization function
visualize_network_raw <- function(g, title, layout_coords, party_names) {
  # Color and size nodes (matching reference)
  igraph::V(g)$color <- party_colors[igraph::V(g)$party_type]
  igraph::V(g)$size <- pmax(8, sqrt(igraph::degree(g)) * 4)
  
  # Edge styling for raw networks
  if(snafun::count_edges(g) > 0) {
    # Use raw weights for visualization
    igraph::E(g)$width <- pmax(0.5, (igraph::E(g)$weight / max(igraph::E(g)$weight)) * 3)
    mean_raw <- mean(igraph::E(g)$weight)
    threshold <- mean_raw * 1.3
    igraph::E(g)$color <- ifelse(igraph::E(g)$weight >= threshold,
                                 grDevices::rgb(0.3, 0.3, 0.3, 0.8),
                                 grDevices::rgb(0.5, 0.5, 0.5, 0.15))
  }
  
  # Match layout to party order
  layout_match <- layout_coords[match(igraph::V(g)$name, party_names), ]
  
  plot(g, layout = layout_match,
       vertex.label.cex = 0.7,
       vertex.label.color = "black",
       vertex.frame.color = "white",
       main = title)
}

# Visualize networks
par(mfrow = c(1, 2), mar = c(2, 2, 4, 2))
visualize_network_raw(g_pre_viz, "PRE-ELECTION\n(Nov 22, 2022 - Nov 21, 2023)", 
                      layout_coords, nodelist$name)
visualize_network_raw(g_post_viz, "POST-FORMATION\n(Jul 5, 2024 - Jul 4, 2025)", 
                      layout_coords, nodelist$name)
```

## 2.4 Edge Weight Statistics

```{r edge-weight-stats}
# Compare raw weights between periods
print("EDGE WEIGHT STATISTICS")
print("======================")
print("")
print("RAW WEIGHT COMPARISON:")
print(sprintf("Pre-election: Mean = %.1f, SD = %.1f, Range = [%.0f, %.0f]",
              mean(edgelist_pre$weight), sd(edgelist_pre$weight),
              min(edgelist_pre$weight), max(edgelist_pre$weight)))
print(sprintf("Post-formation: Mean = %.1f, SD = %.1f, Range = [%.0f, %.0f]",
              mean(edgelist_post$weight), sd(edgelist_post$weight),
              min(edgelist_post$weight), max(edgelist_post$weight)))
```

## 2.5 Co-Sponsorship Exploration

Co-sponsorship edge lists are now pre-generated by the Python script and loaded from CSV files.

```{r cosponsorship-exploration}
# Load pre-generated co-sponsorship edge lists
edgelist_cosponsor_pre <- read.csv("results/edge_lists/cosponsor_pre_election.csv", stringsAsFactors = FALSE)
edgelist_cosponsor_post <- read.csv("results/edge_lists/cosponsor_post_formation.csv", stringsAsFactors = FALSE)
  
  print("CO-SPONSORSHIP EXPLORATION")
  print("===========================")
print("Co-sponsorship edge lists generated by generate_edgelists.py")
  print("")
  
  # Pre-election analysis
  print("PRE-ELECTION:")
  print(sprintf("  Total co-sponsorship pairs: %d", nrow(edgelist_cosponsor_pre)))
  if(nrow(edgelist_cosponsor_pre) > 0) {
    print(sprintf("  Mean co-sponsorships per pair: %.1f", mean(edgelist_cosponsor_pre$weight)))
    print(sprintf("  Max co-sponsorships: %.0f", max(edgelist_cosponsor_pre$weight)))
} else {
  print("  No co-sponsorship relationships found in pre-election period")
  }
  
  print("")
  print("POST-FORMATION:")
  print(sprintf("  Total co-sponsorship pairs: %d", nrow(edgelist_cosponsor_post)))
  if(nrow(edgelist_cosponsor_post) > 0) {
    print(sprintf("  Mean co-sponsorships per pair: %.1f", mean(edgelist_cosponsor_post$weight)))
    print(sprintf("  Max co-sponsorships: %.0f", max(edgelist_cosponsor_post$weight)))
} else {
  print("  No co-sponsorship relationships found in post-formation period")
}
```

## 2.6 Coalition Exploration

```{r coalition-exploration}
# Load pre-generated coalition edge list
coalition_edgelist_filtered <- read.csv("results/edge_lists/coalition_edges.csv", stringsAsFactors = FALSE)

print("COALITION EXPLORATION")
print("=====================")
print("Coalition edge list generated by generate_edgelists.py")
print(sprintf("Total coalition edges: %d", nrow(coalition_edgelist_filtered)))
if(nrow(coalition_edgelist_filtered) > 0) {
  print(sprintf("Mean coalition count: %.1f", mean(coalition_edgelist_filtered$weight)))
  print(sprintf("Max coalition count: %.0f", max(coalition_edgelist_filtered$weight)))
  
  # Top coalition pairs
  coalition_sorted <- coalition_edgelist_filtered[order(-coalition_edgelist_filtered$weight), ]
  print("")
  print("Top 5 coalition pairs:")
  for(i in seq_len(min(5, nrow(coalition_sorted)))) {
    print(sprintf("  %d. %s - %s: %d times", i, coalition_sorted$from[i], 
                  coalition_sorted$to[i], coalition_sorted$weight[i]))
  }
}
```

------------------------------------------------------------------------

# 3. Study 1 Preprocessing (QAP)

## 3.1 Use Fully Connected Networks

Study 1 compares network structures between pre-election and post-formation periods using QAP (Quadratic Assignment Procedure). We use the fully connected networks created in general preprocessing.

```{r study1-networks}
# Study 1 uses the fully connected networks from general preprocessing
g_study1_pre_connected <- g_pre_connected
g_study1_post_connected <- g_post_connected

print("STUDY 1: USING FULLY CONNECTED NETWORKS")
print("========================================")
print(sprintf("Pre-election: %d nodes, fully connected", 
              snafun::count_vertices(g_study1_pre_connected)))
print(sprintf("Post-formation: %d nodes, fully connected", 
              snafun::count_vertices(g_study1_post_connected)))
print("Networks ready for QAP analysis")
```

------------------------------------------------------------------------

# 4. Study 2 Preprocessing (GERGM)

## 4.1 Add Ideology Attributes to Fully Connected Networks

Study 2 uses GERGM (Generalized Exponential Random Graph Model) to model network formation with covariates. We start with the fully connected networks from general preprocessing and add ideology attributes to vertices.

```{r study2-networks}
# Study 2 uses the fully connected networks from general preprocessing
# Ideology attributes are already in the nodelist, just copy to networks
g_study2_pre <- g_pre_connected
g_study2_post <- g_post_connected

# The left_right attribute is already available from nodelist creation

print("STUDY 2: IDEOLOGY ATTRIBUTES ADDED")
print("===================================")
print(sprintf("Pre-election: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_pre), snafun::count_edges(g_study2_pre)))
print(sprintf("Post-formation: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_post), snafun::count_edges(g_study2_post)))
print("Left-right ideology attributes added to vertices")
```

## 4.2 Add Co-Sponsorship and Coalition Edge Attributes

```{r study2-edge-attributes}
# Function to add edge attribute from edgelist
add_edge_attribute <- function(g_voting, edgelist_attribute, attr_name) {
  edges_voting <- igraph::as_data_frame(g_voting, what = "edges")
  
  # Create canonical party pair names (alphabetical order) for matching
  edges_voting$party_pair <- paste(
    pmin(edges_voting$from, edges_voting$to),
    pmax(edges_voting$from, edges_voting$to),
    sep = "_"
  )
  

  # Create canonical party pair names for attribute edges
  if(nrow(edgelist_attribute) > 0) {
    edgelist_attribute$party_pair <- paste(
      pmin(edgelist_attribute$from, edgelist_attribute$to),
      pmax(edgelist_attribute$from, edgelist_attribute$to),
      sep = "_"
    )
    
    # Match attribute weights to voting edges
    attr_lookup <- edgelist_attribute$weight
    names(attr_lookup) <- edgelist_attribute$party_pair
    
    # Add attribute (0 if no relationship)
    edges_voting[[attr_name]] <- ifelse(
      edges_voting$party_pair %in% names(attr_lookup),
      attr_lookup[edges_voting$party_pair],
      0
    )
  } else {
    edges_voting[[attr_name]] <- 0
  }
  
  # Remove temporary party_pair column
  edges_voting$party_pair <- NULL
  
  # Recreate graph with attribute
  g_with_attr <- igraph::graph_from_data_frame(edges_voting, directed = FALSE,
                                                vertices = igraph::V(g_voting)$name)
  
  # Copy vertex attributes
  for(attr in igraph::list.vertex.attributes(g_voting)) {
    if(attr != "name") {
      igraph::vertex_attr(g_with_attr, attr) <- igraph::vertex_attr(g_voting, attr)
    }
  }
  
  return(g_with_attr)
}

# Load pre-generated filtered edge lists for Study 2
edgelist_cosponsor_pre_filtered <- read.csv("results/edge_lists/study2_cosponsor_pre_election.csv", stringsAsFactors = FALSE)
edgelist_cosponsor_post_filtered <- read.csv("results/edge_lists/study2_cosponsor_post_formation.csv", stringsAsFactors = FALSE)
coalition_edgelist_pre_filtered <- read.csv("results/edge_lists/study2_coalition_filtered.csv", stringsAsFactors = FALSE)
coalition_edgelist_post_filtered <- read.csv("results/edge_lists/study2_coalition_filtered.csv", stringsAsFactors = FALSE)

# Add edge attributes
g_study2_pre <- add_edge_attribute(g_study2_pre, edgelist_cosponsor_pre_filtered, "cosponsor_count")
g_study2_pre <- add_edge_attribute(g_study2_pre, coalition_edgelist_pre_filtered, "coalition_count")

g_study2_post <- add_edge_attribute(g_study2_post, edgelist_cosponsor_post_filtered, "cosponsor_count")
g_study2_post <- add_edge_attribute(g_study2_post, coalition_edgelist_post_filtered, "coalition_count")

print("STUDY 2: EDGE ATTRIBUTES ADDED")
print("===============================")
print("Co-sponsorship and coalition counts added as edge attributes")
print("Networks are already fully connected from general preprocessing")
print("Networks ready for GERGM analysis")
```

------------------------------------------------------------------------

# 5. QAP Analysis (Study 1)

## 5.1 Overview

QAP (Quadratic Assignment Procedure) is used in Study 1 to test whether the network structure changed significantly between the pre-election and post-formation periods. QAP compares two networks by:

1.  Computing a test statistic (e.g., correlation) between the two adjacency matrices
2.  Permuting rows and columns of one matrix to generate a null distribution
3.  Comparing the observed statistic to the null distribution to assess significance

## 5.2 Prepare Data for QAP

```{r qap-prepare}
# Load required packages
if(!require(sna)) install.packages("sna")
library(sna)

# Create results directory if it doesn't exist
if(!dir.exists("results/statistics")) {
  dir.create("results/statistics", recursive = TRUE)
}

# Ensure matrices are properly aligned (same row/column order)
# Both matrices should already have the same party order from Study 1 preprocessing
party_order <- rownames(adj_matrix_pre)

# Verify alignment
if(!all(rownames(adj_matrix_pre) == rownames(adj_matrix_post)) ||
   !all(colnames(adj_matrix_pre) == colnames(adj_matrix_post))) {
  stop("Adjacency matrices are not aligned!")
}

print("QAP DATA PREPARATION")
print("====================")
print(sprintf("Pre-election matrix: %d x %d", nrow(adj_matrix_pre), ncol(adj_matrix_pre)))
print(sprintf("Post-formation matrix: %d x %d", nrow(adj_matrix_post), ncol(adj_matrix_post)))
print(sprintf("Number of parties: %d", length(party_order)))
print("Matrices are aligned and ready for QAP analysis")
```

## 5.3 Network-Level Metrics Comparison

```{r qap-metrics}
# Calculate network-level metrics for comparison
# Using snafun for basic metrics and base R/igraph for others

# Pre-election metrics
g_pre <- g_study1_pre_connected
g_post <- g_study1_post_connected

metrics_pre <- list(
  vertices = snafun::count_vertices(g_pre),
  edges = snafun::count_edges(g_pre),
  density = snafun::g_density(g_pre),
  mean_degree = mean(igraph::degree(g_pre)),
  mean_weight = mean(igraph::E(g_pre)$weight),
  max_weight = max(igraph::E(g_pre)$weight),
  min_weight = min(igraph::E(g_pre)$weight)
)

metrics_post <- list(
  vertices = snafun::count_vertices(g_post),
  edges = snafun::count_edges(g_post),
  density = snafun::g_density(g_post),
  mean_degree = mean(igraph::degree(g_post)),
  mean_weight = mean(igraph::E(g_post)$weight),
  max_weight = max(igraph::E(g_post)$weight),
  min_weight = min(igraph::E(g_post)$weight)
)

# Create comparison table
metrics_comparison <- data.frame(
  Metric = c("Vertices", "Edges", "Density", "Mean Degree", 
             "Mean Weight", "Max Weight", "Min Weight"),
  Pre_Election = c(
    metrics_pre$vertices,
    metrics_pre$edges,
    sprintf("%.4f", metrics_pre$density),
    sprintf("%.2f", metrics_pre$mean_degree),
    sprintf("%.4f", metrics_pre$mean_weight),
    sprintf("%.4f", metrics_pre$max_weight),
    sprintf("%.4f", metrics_pre$min_weight)
  ),
  Post_Formation = c(
    metrics_post$vertices,
    metrics_post$edges,
    sprintf("%.4f", metrics_post$density),
    sprintf("%.2f", metrics_post$mean_degree),
    sprintf("%.4f", metrics_post$mean_weight),
    sprintf("%.4f", metrics_post$max_weight),
    sprintf("%.4f", metrics_post$min_weight)
  ),
  stringsAsFactors = FALSE
)

print("NETWORK-LEVEL METRICS COMPARISON")
print("=================================")
print(metrics_comparison)
```

## 5.4 QAP Correlation Test

```{r qap-correlation}
# Perform QAP correlation test using matrices directly
# This tests whether the correlation between the two networks is significant
# H1.1: Dutch political parties show different levels of voting agreement 
#       before elections compared to after cabinet formation
# Note: Warnings about "standard deviation is zero" during permutations are 
#       typically harmless and occur when some permuted rows/columns are constant
set.seed(12345)

# Compute observed correlation
observed_corr <- sna::gcor(adj_matrix_pre, adj_matrix_post)
print(sprintf("Observed correlation: %.4f", observed_corr))

# Perform QAP test using matrices directly (sna::gcor works with matrices)
suppressWarnings({
  qap_result <- sna::qaptest(
    list(adj_matrix_pre, adj_matrix_post),
    FUN = sna::gcor,
    reps = 1000,
    g1 = 1,
    g2 = 2
  )
})

print("QAP CORRELATION TEST")
print("====================")
print(sprintf("Observed correlation: %.4f", qap_result$testval))
print(sprintf("Number of permutations: %d", qap_result$reps))
print("")
print("QAP Test Summary:")
print(summary(qap_result))
print("")
print("QAP Test Plot:")
plot(qap_result)
```

## 5.5 QAP Results Interpretation

```{r qap-interpretation}
# Extract p-value and interpret results
p_value <- mean(qap_result$dist >= qap_result$testval)

print("QAP RESULTS INTERPRETATION")
print("===========================")
print(sprintf("Observed correlation: %.4f", qap_result$testval))
print(sprintf("P-value (one-tailed): %.4f", p_value))
print(sprintf("P-value (two-tailed): %.4f", 2 * min(p_value, 1 - p_value)))
print("")
if(p_value < 0.05) {
  print("Interpretation: The correlation between pre-election and post-formation")
  print("networks is statistically significant (p < 0.05).")
  print("The network structures are significantly similar.")
} else {
  print("Interpretation: The correlation between pre-election and post-formation")
  print("networks is NOT statistically significant (p >= 0.05).")
  print("The network structures differ significantly between periods.")
}

# Save QAP results
qap_summary <- list(
  observed_correlation = qap_result$testval,
  p_value_one_tailed = p_value,
  p_value_two_tailed = 2 * min(p_value, 1 - p_value),
  n_permutations = qap_result$reps,
  interpretation = ifelse(p_value < 0.05, 
                         "Networks are significantly similar",
                         "Networks differ significantly")
)

# Export results
save(qap_result, qap_summary, metrics_comparison,
     file = "results/statistics/qap_results.RData")
print("")
print("QAP results saved to results/statistics/qap_results.RData")
```

------------------------------------------------------------------------

# 6. ERGM Setup

## 6.1 Overview

GERGM (Generalized Exponential Random Graph Model) will be used in Study 2 to model network formation with covariates. GERGM allows us to test hypotheses about which factors influence voting agreement between parties.

## 6.2 Hypotheses and Model Terms

The GERGM will test the following hypotheses:

-   **H2.1**: Parties with similar ideologies on the left-right spectrum are more likely to agree on motions.
    -   *Term*: `absdiff(LeftVSRight)` - measures how differences in ideology impact tie formation
-   **H2.2**: Parties that have often been in a coalition together are more likely to agree on motions.
    -   *Term*: `edgecov(coalitioncount)` - uses coalition count as edge covariate
-   **H2.3**: Parties are more likely to agree on motions if they share agreement on motions with a third party.
    -   *Term*: `gwesp` - captures transitivity/triadic closure
-   **H2.4**: Some parties are more likely to agree with many other parties.
    -   *Term*: `kstar(3)` - captures tendency for some parties to form broader cooperation patterns
-   **H2.5**: Parties who frequently co-sponsor motions tend to agree more with each other.
    -   *Term*: `edgecov(cosponsor_count)` - uses co-sponsorship count as edge covariate

```{r eval=FALSE}

nodelist <- data.frame(
  name = sort(ideology_data$party),
  left_right = ideology_data$left_right[match(sort(ideology_data$party), ideology_data$party)],
  conservative_progressive = ideology_data$conservative_progressive[match(sort(ideology_data$party), ideology_data$party)],
  stringsAsFactors = FALSE
)


g_pre <- igraph::graph_from_data_frame(d = edgelist_pre, vertices = nodelist, directed = FALSE)
g_post <- igraph::graph_from_data_frame(d = edgelist_post, vertices = nodelist, directed = FALSE)

snafun::g_summary(g_pre)
snafun::g_summary(g_post)




```

## Pre election network Prep

```{r eval=FALSE}

## Create cleaned network
# Pre
g_study2_pre_cleaned <- g_study2_pre
snafun::g_summary(g_study2_pre_cleaned)
# Post
g_study2_post_cleaned <- g_study2_post
snafun::g_summary(g_study2_post_cleaned)


##Remove nodes of parties not present in these elections
# Pre
pre_nodes_to_remove <- c("GroenLinks-PvdA","Omtzigt", "NSC", "BIJ1", "BVNL", '50PLUS')
g_study2_pre_cleaned <- snafun::remove_vertices(g_study2_pre_cleaned,pre_nodes_to_remove)
# Post
post_nodes_to_remove <- c("GroenLinks","Omtzigt", "PvdA", "BIJ1", "BVNL", '50PLUS')
g_study2_post_cleaned <- snafun::remove_vertices(g_study2_post_cleaned,post_nodes_to_remove)


## Edge weight: motion counts as fractions of total motions
# Pre
total_motions_pre  <- length(unique(motion_data_pre$Besluit_Id))
counted_weights_pre <- igraph::E(g_study2_pre_cleaned)$weight
igraph::E(g_study2_pre_cleaned)$weight_count <- counted_weights_pre
igraph::E(g_study2_pre_cleaned)$weight <- counted_weights_pre / total_motions_pre
snafun::g_summary(g_study2_pre_cleaned)
edge_weights_pre <- igraph::E(g_study2_pre_cleaned)$weight
# Post
total_motions_post  <- length(unique(motion_data_post$Besluit_Id))
counted_weights_post <- igraph::E(g_study2_post_cleaned)$weight
igraph::E(g_study2_post_cleaned)$weight_count <- counted_weights_post
igraph::E(g_study2_post_cleaned)$weight <- counted_weights_post / total_motions_post
snafun::g_summary(g_study2_post_cleaned)
edge_weights_post <- igraph::E(g_study2_post_cleaned)$weight


## Cut-off threshold percentages to investigate
prob <- c(0.25, 0.50, 0.60, 0.68, 0.70, 0.75)
name <- c("p25","p50","p60","p68", "p70", "p75")
#Pre
cutoffs_pre <- quantile(edge_weights_pre, probs = prob, na.rm = TRUE)
cutoffs_pre <- as.list(cutoffs_pre)
names(cutoffs_pre) <- name
# Post
cutoffs_post <- quantile(edge_weights_post, probs = prob, na.rm = TRUE)
cutoffs_post <- as.list(cutoffs_post)
names(cutoffs_post) <- name



g_pre_list <- list()
g_post_list <- list()
dist_pre_list <- list()
dist_post_list <- list()
summary_pre_list <- list()
summary_post_list <- list()

```


### Loop voor alle pre-thresholds

```{r}
for (name in names(cutoffs_pre)){
  threshold <- cutoffs_pre[[name]]
  
  # Subgraph generation
  graph_temporary <- igraph::subgraph.edges(
    g_study2_pre_cleaned,
    eids = igraph::E(g_study2_pre_cleaned)[
      igraph::E(g_study2_pre_cleaned)$weight >= threshold],
    delete.vertices = FALSE
  )
  
  # Binarize Subgraph
  igraph::E(graph_temporary)$weight <- 1
  
  cat("Pre-", name)
  
  summary_temp <- snafun::g_summary(graph_temporary)
  summary_pre_list[[name]] <- summary_temp
  
  print(summary_temp)
  
  snafun::plot(graph_temporary, main = paste("Pre-",name))
  g_pre_list[[name]] <- graph_temporary
  
  # Analyse Subgraph
  dist_pre <- snafun::g_degree_distribution(graph_temporary)
  dist_pre_list[[name]] <- dist_pre
  values <- as.numeric(dist_pre[1, ])
  barplot(values, names.arg = colnames(dist_pre), xlab="Index", ylab="Value", main = paste("Degree distribution pre-", name))
}

for (name in names(g_pre_list)) {
  new_name <- paste("g", name, "pre", sep="_")
  assign(new_name, g_pre_list[[name]])
}

```
#### Loop voor alle post-thresholds

```{r}
for (name in names(cutoffs_post)){
  threshold <- cutoffs_post[[name]]
  
  # Subgraph generation
  graph_temporary <- igraph::subgraph.edges(
    g_study2_post_cleaned,
    eids = igraph::E(g_study2_post_cleaned)[
      igraph::E(g_study2_post_cleaned)$weight >= threshold],
    delete.vertices = FALSE
  )
  
  # Binarize Subgraph
  igraph::E(graph_temporary)$weight <- 1
  
  cat("Post-", name)
  
  summary_temp <- snafun::g_summary(graph_temporary)
  summary_post_list[[name]] <- summary_temp
  
  print(summary_temp)
  
  snafun::plot(graph_temporary, main = paste("Post-",name))
  g_post_list[[name]] <- graph_temporary
  
  # Analyse Subgraph
  dist_post <- snafun::g_degree_distribution(graph_temporary)
  dist_post_list[[name]] <- dist_post
  values <- as.numeric(dist_post[1, ])
  barplot(values, names.arg = colnames(dist_post), xlab="Index", ylab="Value", main = paste("Degree distribution post-", name))
}

for (name in names(g_post_list)) {
  new_name <- paste("g", name, "post", sep="_")
  assign(new_name, g_post_list[[name]])
}

```

#### ERGM Prep

```{r}
## Pre

thresholded_pre <- g_p68_pre

party_names <- igraph::V(thresholded_pre)$name
igraph::V(thresholded_pre)$left_right <- nodelist$left_right[
  match(party_names, nodelist$name)]
  
thresholded_pre_net <- snafun::to_network(thresholded_pre)

network::set.vertex.attribute(thresholded_pre_net, "left_right", igraph::V(thresholded_pre)$left_right)

cosponsor_mat  <- as.matrix.network(thresholded_pre_net, attrname = "cosponsor_count")
coalition_mat  <- as.matrix.network(thresholded_pre_net, attrname = "coalition_count")

## Post

thresholded_post <- g_p68_post

party_names <- igraph::V(thresholded_post)$name
igraph::V(thresholded_post)$left_right <- nodelist$left_right[
  match(party_names, nodelist$name)]
  
thresholded_post_net <- snafun::to_network(thresholded_post)

network::set.vertex.attribute(thresholded_post_net, "left_right", igraph::V(thresholded_post)$left_right)

cosponsor_mat  <- as.matrix.network(thresholded_post_net, attrname = "cosponsor_count")
coalition_mat  <- as.matrix.network(thresholded_post_net, attrname = "coalition_count")

```

#### ERGM Run Pre

```{r}
# Exogenous ERGMs

Model1 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model2 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    edgecov(cosponsor_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model3 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model4 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model5 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    absdiff("left_right") +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model6 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model7 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    edgecov(coalition_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

texreg::screenreg(list(Model1, Model2, Model3, Model4, Model5, Model6, Model7))

```




```{r}
# Structural ERGMs

Model1 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    gwesp(0.1, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

Model2 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    kstar(3),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)


Model3 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    #gwdegree(0.1, fixed=TRUE) +
    kstar(3)+  
    gwesp(0.1, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

texreg::screenreg(list(Model1, Model2, Model3))

```


```{r}

#Final Model

FinalModel <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    kstar(3) +
    gwesp(0.1, fixed = TRUE) +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)
```


#### ERGM Interpret Pre

```{r}

ergm_analysis <- function(model, prefix) {

  output_dir <- "results"
  if (!dir.exists(output_dir)) {dir.create(output_dir)}
  
  # Summary
  summary_file <- file.path(output_dir, paste(prefix, "summary.txt"))
  summary_content <- capture.output(summary(model))
  writeLines(summary_content, summary_file)
  cat("Model summary saved in", summary_file, "\n")
  
  # MCMC Diagnostics (plots)
  mcmc_diag_file <- file.path(output_dir, paste(prefix, "mcmc.pdf"))
  pdf(mcmc_diag_file)
  dev.off()
  cat("MCMC saved in ", mcmc_diag_file, "\n")
  
  # GOF (plots)
  gof_results <- ergm::gof(model)
  gof_plot_file <- file.path(output_dir, paste(prefix, "gof.pdf"))
  pdf(gof_plot_file)
  dev.off()
  cat("GOF saved in", gof_plot_file, "\n")

}

ergm_analysis(FinalModel, "pre-election")

```

#### ERGM Run Post

```{r}
# Exogenous ERGMs

Model1 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model2 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(cosponsor_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model3 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model4 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model5 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    absdiff("left_right") +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model6 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

Model7 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    edgecov(coalition_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK"
  )
)

texreg::screenreg(list(Model1, Model2, Model3, Model4, Model5, Model6, Model7))

```

```{r}
# Structural ERGMs

Model1 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    gwesp(0.1, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

Model2 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    kstar(3),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)


Model3 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    #gwdegree(0.1, fixed=TRUE) +
    kstar(3)+  
    gwesp(0.1, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

texreg::screenreg(list(Model1, Model2, Model3))

```

```{r}

#Final Model

FinalModel <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    kstar(3) +
    gwesp(0.1, fixed = TRUE) +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 6,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)
```


#### ERGM Interpret Pre
```{r}
ergm_analysis(FinalModel, "post-election")

```





# 7. Summary

## 7.1 Preprocessing Summary

```{r summary}
print("PREPROCESSING SUMMARY")
print("====================")
print("")
print("DATA PREPARATION:")
print(sprintf("  • Pre-election: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_pre), big.mark = ","),
              format(length(unique(motion_data_pre$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_pre$ActorFractie))))
print(sprintf("  • Post-formation: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_post), big.mark = ","),
              format(length(unique(motion_data_post$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_post$ActorFractie))))
print("")
print("FULLY CONNECTED NETWORKS (GENERAL PREPROCESSING):")
print(sprintf("  • Pre-election: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_pre_connected), snafun::count_edges(g_pre_connected)))
print(sprintf("  • Post-formation: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_post_connected), snafun::count_edges(g_post_connected)))
print("  • All zero edge weights set to 1e-6 for full connectivity")
print("  • Adjacency matrices exported")
print("")
print("STUDY 1 (QAP):")
print("  • Uses fully connected networks from general preprocessing")
print("  • Ready for QAP correlation test")
print("")
print("STUDY 2 (GERGM):")
print(sprintf("  • Pre-election: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_pre), snafun::count_edges(g_study2_pre)))
print(sprintf("  • Post-formation: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_post), snafun::count_edges(g_study2_post)))
print("  • Same node set for comparability between periods")
print("  • Ideology, co-sponsorship, and coalition attributes added")
print("  • Ready for GERGM analysis")
```

## 7.2 Files Generated

All preprocessing outputs have been saved to:

-   **Adjacency Matrices:** `results/adjacency_matrices/`
    -   `pre_election_adjacency.csv`
    -   `post_formation_adjacency.csv`
-   **Statistics:** `results/statistics/`
-   **Visualizations:** `results/visualizations/`

------------------------------------------------------------------------

# Session Info

```{r session-info}
sessionInfo()
```
