---
title: "Electoral Cycle Network Analysis: Dutch Parliament 2023-2024"
subtitle: "Pre-Election vs. Post-Formation Party Cooperation Networks"
author: "Your Name"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: show
    theme: flatly
    highlight: tango
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  results = 'asis',
  fig.width = 12,
  fig.height = 8,
  fig.path = "results/visualizations/"
)
print(paste("Working directory set to:", getwd()))
```

------------------------------------------------------------------------

# 1. Data Preparation

## 1.1 Load Data

```{r load-data}

# Load voting data
voting_data_pre <- read.csv("data/voting_data_2023_preelection.csv", stringsAsFactors = FALSE)
voting_data_post <- read.csv("data/voting_data_clean.csv", stringsAsFactors = FALSE)

# Convert dates
voting_data_pre$date <- lubridate::ymd_hms(voting_data_pre$GewijzigdOp)
voting_data_post$date <- lubridate::ymd_hms(voting_data_post$GewijzigdOp)

# Load Kieskompas ideology data
ideology_data <- read.csv("data/political_axes_data.csv", stringsAsFactors = FALSE)
names(ideology_data) <- c("left_right", "conservative_progressive", "party")
ideology_data <- ideology_data[!is.na(ideology_data$party) & ideology_data$party != "", ]

#load cosponsoring data
edgelist_cosponsor_pre <- read.csv("results/edge_lists/cosponsor_pre_election.csv", stringsAsFactors = FALSE)
edgelist_cosponsor_post <- read.csv("results/edge_lists/cosponsor_post_formation.csv", stringsAsFactors = FALSE)

#load coalition data
edgelist_pre_coalition <- read.csv2("results/edge_lists/study2_coalition_filtered_pre.csv")
edgelist_post_coalition <- read.csv("results/edge_lists/study2_coalition_filtered_post.csv")

# Load pre-generated edge lists
edgelist_pre <- read.csv("results/edge_lists/edges_pre_election.csv", stringsAsFactors = FALSE)
edgelist_post <- read.csv("results/edge_lists/edges_post_formation.csv", stringsAsFactors = FALSE)
```

## Generate Pre and Post election networks

```{r}

#generate named vectors of parties to remove from the dataset
parties_to_remove_general <- c("Omtzigt","BIJ1", "BVNL", "50PLUS")
nodes_to_remove_pre <- c("GroenLinks-PvdA","Omtzigt", "NSC", "BIJ1", "BVNL", '50PLUS')
nodes_to_remove_post <- c("GroenLinks","Omtzigt", "PvdA", "BIJ1", "BVNL", '50PLUS')

#generate node lists for the networks of both studies
parties <- ideology_data$party

parties_filtered <- parties[!parties %in% parties_to_remove_general]
parties_pre <- parties[!parties %in% nodes_to_remove_pre]
parties_post <- parties[!parties %in% nodes_to_remove_post]

#filter out edges from the edgelist of pre and post
edges_filtered_pre <- edgelist_pre[
  edgelist_pre$from %in% parties_pre &
  edgelist_pre$to   %in% parties_pre,
]

edges_filtered_post <- edgelist_post[
  edgelist_post$from %in% parties_post &
  edgelist_post$to   %in% parties_post,
]


#make graphs for pre and post using the filtered edgelist

g_pre <- igraph::graph_from_data_frame(edges_filtered_pre, directed = FALSE)
g_post <- igraph::graph_from_data_frame(edges_filtered_post, directed = FALSE)

```

## Study 1 Pre-processing

Study 1 requires fully connected networks. We create these networks with all parties from the ideology data, setting zero edge weights to 1e-6 for full connectivity.

```{r}

#generate networks using filtered edgelist and vertices present in both networks
g_pre_connected <- igraph::graph_from_data_frame(
  d = edges_filtered_pre,
  directed = FALSE,
  vertices = parties_filtered
)

g_post_connected <- igraph::graph_from_data_frame(
  d = edges_filtered_post,
  directed = FALSE,
  vertices = parties_filtered
)



#extract adjacency matrix
adj_matrix_pre <- igraph::as_adjacency_matrix(g_pre_connected, attr = "weight", sparse = FALSE)
adj_matrix_post <- igraph::as_adjacency_matrix(g_post_connected, attr = "weight", sparse = FALSE)

# Set 0 values to 1e-6 to make fully connected
adj_matrix_pre[adj_matrix_pre == 0] <- 1e-6
adj_matrix_post[adj_matrix_post == 0] <- 1e-6

#re-remove selfloops
diag(adj_matrix_pre) <- 0
diag(adj_matrix_post) <- 0


#recreate networks
g_pre_connected <- igraph::graph_from_adjacency_matrix(adj_matrix_pre, 
                                                       mode = "undirected", 
                                                       weighted = TRUE)
g_post_connected <- igraph::graph_from_adjacency_matrix(adj_matrix_post, 
                                                        mode = "undirected",
                                                        weighted = TRUE)


#output as CSV for documentation
write.csv(adj_matrix_pre, "results/adjacency_matrices/pre_election_adjacency.csv", 
          row.names = TRUE)

write.csv(adj_matrix_post, "results/adjacency_matrices/post_formation_adjacency.csv",
          row.names = TRUE)

```

## Study 2 Pre-processing

```{r}

###Add ideology data 
###Add cosponsor data
###coalition data



#Filtering edgelist on parties in the network
edgelist_post_coalition_filtered <- subset(edgelist_post_coalition,from %in% party_names & to %in% party_names)

g_post_coa <- igraph::graph_from_data_frame(edgelist_post_coalition_filtered,FALSE,data.frame(name = party_names))

coalition_post_mat <- igraph::as_adjacency_matrix(g_post_coa, attr = 'weight', sparse = FALSE)

#Adding cosponsoring

edgelist_post_cosponsor <- read.csv("results/edge_lists/cosponsor_post_formation.csv")
#Filtering edgelist on parties in the network
edgelist_post_cosponsor_filtered <- subset(edgelist_post_cosponsor,from %in% party_names & to %in% party_names)
g_post_cos <- igraph::graph_from_data_frame(edgelist_post_cosponsor,FALSE,data.frame(name = party_names))
cosponsor_post_mat <- igraph::as_adjacency_matrix(g_post_cos, attr = 'weight', sparse = FALSE)

```

------------------------------------------------------------------------

# 2. Data Exploration

## 2.1 Ideology Correlation

```{r ideology-correlation}
# Pearson correlation between ideology dimensions
pearson_test <- stats::cor.test(ideology_data$left_right, 
                         ideology_data$conservative_progressive, 
                         method = "pearson")

print("IDEOLOGY CORRELATION")
print("====================")
print(sprintf("Pearson r = %.3f (p = %.4f)", pearson_test$estimate, pearson_test$p.value))

# Scatterplot
plot(ideology_data$left_right, ideology_data$conservative_progressive,
     xlab = "Left-Right", ylab = "Conservative-Progressive",
     main = sprintf("Ideology Dimensions (r = %.3f)", pearson_test$estimate),
     pch = 19, col = "steelblue")
abline(lm(conservative_progressive ~ left_right, data = ideology_data), 
       col = "red", lwd = 2)
text(ideology_data$left_right, ideology_data$conservative_progressive, 
     labels = ideology_data$party, pos = 3, cex = 0.7)
```

## 2.2 Vote Unanimity

```{r vote-unanimity}
# Calculate agreement rates per motion
calculate_agreement_rate <- function(data) {
  unique_votes <- data[, c("Besluit_Id", "ActorFractie", "Soort")]
  unique_votes <- unique_votes[!duplicated(unique_votes), ]
  unique_motions <- unique(unique_votes$Besluit_Id)
  
  agreement_rates <- sapply(unique_motions, function(motion_id) {
    motion_votes <- unique_votes[unique_votes$Besluit_Id == motion_id, ]
    voor <- sum(motion_votes$Soort == "Voor")
    tegen <- sum(motion_votes$Soort == "Tegen")
    total <- nrow(motion_votes)
    pmax(voor, tegen) / total
  })
  return(agreement_rates)
}

# Calculate for both periods
agreement_pre <- calculate_agreement_rate(voting_data_pre)
agreement_post <- calculate_agreement_rate(voting_data_post)

print("VOTE UNANIMITY")
print("==============")
print(sprintf("Pre-election: Mean agreement = %.3f", mean(agreement_pre)))
print(sprintf("Post-formation: Mean agreement = %.3f", mean(agreement_post)))

# Comparison boxplot
boxplot(list(Pre = agreement_pre, Post = agreement_post),
        main = "Agreement Rate Comparison",
        ylab = "Agreement Rate", col = c("#E74C3C", "#3498DB"))
```

## 2.3 Network Visualizations

```{r network-visualizations}



## 2. Define a “dictionary” that maps vertex names to some group/attribute
##    (PLACEHOLDER: adjust to your real vertex names and groups)
vertex_group_dict <- c(
  "DENK"             = "Left",   # migratie/identiteit links, sociaaleconomisch links
  "BBB"              = "Center", # sociaaleconomisch gematigd, agrarisch-populistisch
  "CDA"              = "Center",
  "D66"              = "Center", # sociaaleconomisch centrum, progressief-liberaal
  "Christenunie"     = "Center", # wat sociaaleconomisch centrum-links, maar religieus
  "SGP"              = "Right",
  "FvD"              = "Right",
  "PVV"              = "Right",
  "PvdA"             = "Left",
  "Groenlinks"       = "Left",
  "VVD"              = "Right",
  "JA21"             = "Right",
  "SP"               = "Left",
  "PvdD"             = "Left",
  "Volt"             = "Center", # pro-EU, vaak tussen links en centrum geclassificeerd
  "GroenLinks-PvdA"  = "Left"
)



igraph::E(g)$width <- pmax(
  0.25,
  (igraph::E(g)$weight / max(igraph::E(g)$weight)) * 2
)

igraph::E(g)$color <- ifelse(
  igraph::E(g)$weight >= threshold,
  grDevices::rgb(0.3, 0.3, 0.3, 0.9),
  grDevices::rgb(0.5, 0.5, 0.5, 0.05)
)


## 3. Define a second dictionary that maps groups → colors
##    (PLACEHOLDER palette; you can change the colors or the group names)
group_to_color <- c(
  "Center" = "steelblue",
  "Right" = "tomato",
  "Left" = "darkgreen"
)

## 4. Convert dictionaries into a vertex color vector in the order of V(g)
vertex_names   <- igraph::V(g_pre)$name                 # e.g., c("A","B","C","D")
vertex_groups  <- vertex_group_dict[vertex_names]   # group per vertex (via “dictionary”)
vertex_colors  <- group_to_color[vertex_groups]     # final color per vertex

## 5. Plot using snafun’s wrapper (works for igraph objects)
snafun::plot(
  g_pre,
  vertex.size       = 18,
  vertex.color      = vertex_colors,
  vertex.label      = vertex_names,
  vertex.label.cex  = 0.9,
  vertex.label.color= "black",
  edge.width        = 2,
  edge.curved       = TRUE
)
```

## 2.4 Edge Weight Statistics

```{r edge-weight-stats}
# Compare raw weights between periods
print("EDGE WEIGHT STATISTICS")
print("======================")
print("")
print("RAW WEIGHT COMPARISON:")
print(sprintf("Pre-election: Mean = %.1f, SD = %.1f, Range = [%.0f, %.0f]",
              mean(edgelist_pre$weight), sd(edgelist_pre$weight),
              min(edgelist_pre$weight), max(edgelist_pre$weight)))
print(sprintf("Post-formation: Mean = %.1f, SD = %.1f, Range = [%.0f, %.0f]",
              mean(edgelist_post$weight), sd(edgelist_post$weight),
              min(edgelist_post$weight), max(edgelist_post$weight)))
```

## 2.5 Co-Sponsorship Exploration

Co-sponsorship edge lists are now pre-generated by the Python script and loaded from CSV files.

```{r cosponsorship-exploration}
  print("CO-SPONSORSHIP EXPLORATION")
  print("===========================")
print("Co-sponsorship edge lists generated by generate_edgelists.py")
  print("")
  
  # Pre-election analysis
  print("PRE-ELECTION:")
  print(sprintf("  Total co-sponsorship pairs: %d", nrow(edgelist_cosponsor_pre)))
  if(nrow(edgelist_cosponsor_pre) > 0) {
    print(sprintf("  Mean co-sponsorships per pair: %.1f", mean(edgelist_cosponsor_pre$weight)))
    print(sprintf("  Max co-sponsorships: %.0f", max(edgelist_cosponsor_pre$weight)))
} else {
  print("  No co-sponsorship relationships found in pre-election period")
  }
  
  print("")
  print("POST-FORMATION:")
  print(sprintf("  Total co-sponsorship pairs: %d", nrow(edgelist_cosponsor_post)))
  if(nrow(edgelist_cosponsor_post) > 0) {
    print(sprintf("  Mean co-sponsorships per pair: %.1f", mean(edgelist_cosponsor_post$weight)))
    print(sprintf("  Max co-sponsorships: %.0f", max(edgelist_cosponsor_post$weight)))
} else {
  print("  No co-sponsorship relationships found in post-formation period")
}
```

## 2.6 Coalition Exploration

```{r coalition-exploration}


print("COALITION EXPLORATION")
print("=====================")
print("Coalition edge list generated by generate_edgelists.py")
print(sprintf("Total coalition edges: %d", nrow(edgelist_pre_coalition)))
if(nrow(edgelist_pre_coalition) > 0) {
  print(sprintf("Mean coalition count: %.1f", mean(edgelist_pre_coalition$weight)))
  print(sprintf("Max coalition count: %.0f", max(edgelist_pre_coalition$weight)))
  
  # Top coalition pairs
  coalition_sorted <- edgelist_pre_coalition[order(-edgelist_pre_coalition$weight), ]
  print("")
  print("Top 5 coalition pairs:")
  for(i in seq_len(min(5, nrow(coalition_sorted)))) {
    print(sprintf("  %d. %s - %s: %d times", i, coalition_sorted$from[i], 
                  coalition_sorted$to[i], coalition_sorted$weight[i]))
  }
}
```

------------------------------------------------------------------------

------------------------------------------------------------------------

# 4. Study 2 Preprocessing (GERGM)

## 4.1 Add Ideology Attributes to Fully Connected Networks

Study 2 uses GERGM (Generalized Exponential Random Graph Model) to model network formation with covariates. We start with the fully connected networks from general preprocessing and add ideology attributes to vertices.

```{r study2-networks}
# Study 2 uses the fully connected networks from general preprocessing
# Ideology attributes are already in the nodelist, just copy to networks
g_study2_pre <- g_pre_connected
g_study2_post <- g_post_connected
# The left_right attribute is already available from nodelist creation

print("STUDY 2: IDEOLOGY ATTRIBUTES ADDED")
print("===================================")
print(sprintf("Pre-election: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_pre), snafun::count_edges(g_study2_pre)))
print(sprintf("Post-formation: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_post), snafun::count_edges(g_study2_post)))
print("Left-right ideology attributes added to vertices")
```

## 4.2 Add Co-Sponsorship and Coalition Edge Attributes

```{r study2-edge-attributes}
# Function to add edge attribute from edgelist
add_edge_attribute <- function(g_voting, edgelist_attribute, attr_name) {
  edges_voting <- igraph::as_data_frame(g_voting, what = "edges")
  
  # Create canonical party pair names (alphabetical order) for matching
  edges_voting$party_pair <- paste(
    pmin(edges_voting$from, edges_voting$to),
    pmax(edges_voting$from, edges_voting$to),
    sep = "_"
  )
  

  # Create canonical party pair names for attribute edges
  if(nrow(edgelist_attribute) > 0) {
    edgelist_attribute$party_pair <- paste(
      pmin(edgelist_attribute$from, edgelist_attribute$to),
      pmax(edgelist_attribute$from, edgelist_attribute$to),
      sep = "_"
    )
    
    # Match attribute weights to voting edges
    attr_lookup <- edgelist_attribute$weight
    names(attr_lookup) <- edgelist_attribute$party_pair
    
    # Add attribute (0 if no relationship)
    edges_voting[[attr_name]] <- ifelse(
      edges_voting$party_pair %in% names(attr_lookup),
      attr_lookup[edges_voting$party_pair],
      0
    )
  } else {
    edges_voting[[attr_name]] <- 0
  }
  
  # Remove temporary party_pair column
  edges_voting$party_pair <- NULL
  
  # Recreate graph with attribute
  g_with_attr <- igraph::graph_from_data_frame(edges_voting, directed = FALSE,
                                                vertices = igraph::V(g_voting)$name)
  
  # Copy vertex attributes
  for(attr in igraph::list.vertex.attributes(g_voting)) {
    if(attr != "name") {
      igraph::vertex_attr(g_with_attr, attr) <- igraph::vertex_attr(g_voting, attr)
    }
  }
  
  return(g_with_attr)
}

# Load pre-generated filtered edge lists for Study 2
edgelist_cosponsor_pre_filtered <- read.csv("results/edge_lists/study2_cosponsor_pre_election.csv", stringsAsFactors = FALSE)
edgelist_cosponsor_post_filtered <- read.csv("results/edge_lists/study2_cosponsor_post_formation.csv", stringsAsFactors = FALSE)
coalition_edgelist_pre_filtered <- read.csv("results/edge_lists/study2_coalition_filtered.csv", stringsAsFactors = FALSE)
coalition_edgelist_post_filtered <- read.csv("results/edge_lists/study2_coalition_filtered.csv", stringsAsFactors = FALSE)

# Add edge attributes
g_study2_pre <- add_edge_attribute(g_study2_pre, edgelist_cosponsor_pre_filtered, "cosponsor_count")
g_study2_pre <- add_edge_attribute(g_study2_pre, coalition_edgelist_pre_filtered, "coalition_count")

g_study2_post <- add_edge_attribute(g_study2_post, edgelist_cosponsor_post_filtered, "cosponsor_count")
g_study2_post <- add_edge_attribute(g_study2_post, coalition_edgelist_post_filtered, "coalition_count")

print("STUDY 2: EDGE ATTRIBUTES ADDED")
print("===============================")
print("Co-sponsorship and coalition counts added as edge attributes")
print("Networks are already fully connected from general preprocessing")
print("Networks ready for GERGM analysis")
```

------------------------------------------------------------------------

# 5. QAP Analysis (Study 1)

## 5.1 Overview

QAP (Quadratic Assignment Procedure) is used in Study 1 to test whether the network structure changed significantly between the pre-election and post-formation periods. QAP compares two networks by:

1.  Computing a test statistic (e.g., correlation) between the two adjacency matrices
2.  Permuting rows and columns of one matrix to generate a null distribution
3.  Comparing the observed statistic to the null distribution to assess significance

## 5.2 Prepare Data for QAP

```{r qap-prepare}

# Ensure matrices are properly aligned (same row/column order)
# Both matrices should already have the same party order from Study 1 preprocessing
party_order <- rownames(adj_matrix_pre)

# Verify alignment
if(!all(rownames(adj_matrix_pre) == rownames(adj_matrix_post)) ||
   !all(colnames(adj_matrix_pre) == colnames(adj_matrix_post))) {
  stop("Adjacency matrices are not aligned!")
}

print("QAP DATA PREPARATION")
print("====================")
print(sprintf("Pre-election matrix: %d x %d", nrow(adj_matrix_pre), ncol(adj_matrix_pre)))
print(sprintf("Post-formation matrix: %d x %d", nrow(adj_matrix_post), ncol(adj_matrix_post)))
print(sprintf("Number of parties: %d", length(party_order)))
print("Matrices are aligned and ready for QAP analysis")
```

## 5.3 Network-Level Metrics Comparison

```{r qap-metrics}
# Calculate network-level metrics for comparison
# Using snafun for basic metrics and base R/igraph for others

# Pre-election metrics

metrics_pre <- list(
  vertices = snafun::count_vertices(g_pre_connected),
  edges = snafun::count_edges(g_pre_connected),
  density = snafun::g_density(g_pre_connected),
  mean_degree = mean(igraph::degree(g_pre_connected)),
  mean_weight = mean(igraph::E(g_pre_connected)$weight),
  max_weight = max(igraph::E(g_pre_connected)$weight),
  min_weight = min(igraph::E(g_pre_connected)$weight)
)

metrics_post <- list(
  vertices = snafun::count_vertices(g_post_connected),
  edges = snafun::count_edges(g_post_connected),
  density = snafun::g_density(g_post_connected),
  mean_degree = mean(igraph::degree(g_post_connected)),
  mean_weight = mean(igraph::E(g_post_connected)$weight),
  max_weight = max(igraph::E(g_post_connected)$weight),
  min_weight = min(igraph::E(g_post_connected)$weight)
)

# Create comparison table
metrics_comparison <- data.frame(
  Metric = c("Vertices", "Edges", "Density", "Mean Degree", 
             "Mean Weight", "Max Weight", "Min Weight"),
  Pre_Election = c(
    metrics_pre$vertices,
    metrics_pre$edges,
    sprintf("%.4f", metrics_pre$density),
    sprintf("%.2f", metrics_pre$mean_degree),
    sprintf("%.4f", metrics_pre$mean_weight),
    sprintf("%.4f", metrics_pre$max_weight),
    sprintf("%.4f", metrics_pre$min_weight)
  ),
  Post_Formation = c(
    metrics_post$vertices,
    metrics_post$edges,
    sprintf("%.4f", metrics_post$density),
    sprintf("%.2f", metrics_post$mean_degree),
    sprintf("%.4f", metrics_post$mean_weight),
    sprintf("%.4f", metrics_post$max_weight),
    sprintf("%.4f", metrics_post$min_weight)
  ),
  stringsAsFactors = FALSE
)

print("NETWORK-LEVEL METRICS COMPARISON")
print("=================================")
print(metrics_comparison)
```

## 5.4 QAP Correlation Test

```{r qap-correlation}
# Perform QAP correlation test using matrices directly
# This tests whether the correlation between the two networks is significant
# H1.1: Dutch political parties show different levels of voting agreement 
#       before elections compared to after cabinet formation
# Note: Warnings about "standard deviation is zero" during permutations are 
#       typically harmless and occur when some permuted rows/columns are constant
set.seed(12345)

# Compute observed correlation
observed_corr <- sna::gcor(adj_matrix_pre, adj_matrix_post)
print(sprintf("Observed correlation: %.4f", observed_corr))

# Perform QAP test using matrices directly (sna::gcor works with matrices)
suppressWarnings({
  qap_result <- sna::qaptest(
    list(adj_matrix_pre, adj_matrix_post),
    FUN = sna::gcor,
    reps = 1000,
    g1 = 1,
    g2 = 2
  )
})

print("QAP CORRELATION TEST")
print("====================")
print(sprintf("Observed correlation: %.4f", qap_result$testval))
print(sprintf("Number of permutations: %d", qap_result$reps))
print("")
print("QAP Test Summary:")
print(summary(qap_result))
print("")
print("QAP Test Plot:")
plot(qap_result)
```

## 5.5 QAP Results Interpretation

```{r qap-interpretation}
# Extract p-value and interpret results
p_value <- mean(qap_result$dist >= qap_result$testval)

print("QAP RESULTS INTERPRETATION")
print("===========================")
print(sprintf("Observed correlation: %.4f", qap_result$testval))
print(sprintf("P-value (one-tailed): %.4f", p_value))
print(sprintf("P-value (two-tailed): %.4f", 2 * min(p_value, 1 - p_value)))
print("")
if(p_value < 0.05) {
  print("Interpretation: The correlation between pre-election and post-formation")
  print("networks is statistically significant (p < 0.05).")
  print("The network structures are significantly similar.")
} else {
  print("Interpretation: The correlation between pre-election and post-formation")
  print("networks is NOT statistically significant (p >= 0.05).")
  print("The network structures differ significantly between periods.")
}

# Save QAP results
qap_summary <- list(
  observed_correlation = qap_result$testval,
  p_value_one_tailed = p_value,
  p_value_two_tailed = 2 * min(p_value, 1 - p_value),
  n_permutations = qap_result$reps,
  interpretation = ifelse(p_value < 0.05, 
                         "Networks are significantly similar",
                         "Networks differ significantly")
)

# Export results
save(qap_result, qap_summary, metrics_comparison,
     file = "results/statistics/qap_results.RData")
print("")
print("QAP results saved to results/statistics/qap_results.RData")
```

------------------------------------------------------------------------

# 6. ERGM Setup

## 6.1 Overview

GERGM (Generalized Exponential Random Graph Model) will be used in Study 2 to model network formation with covariates. GERGM allows us to test hypotheses about which factors influence voting agreement between parties.

## 6.2 Hypotheses and Model Terms

The GERGM will test the following hypotheses:

-   **H2.1**: Parties with similar ideologies on the left-right spectrum are more likely to agree on motions.
    -   *Term*: `absdiff(LeftVSRight)` - measures how differences in ideology impact tie formation
-   **H2.2**: Parties that have often been in a coalition together are more likely to agree on motions.
    -   *Term*: `edgecov(coalitioncount)` - uses coalition count as edge covariate
-   **H2.3**: Parties are more likely to agree on motions if they share agreement on motions with a third party.
    -   *Term*: `gwesp` - captures transitivity/triadic closure
-   **H2.4**: Some parties are more likely to agree with many other parties.
    -   *Term*: `kstar(3)` - captures tendency for some parties to form broader cooperation patterns
-   **H2.5**: Parties who frequently co-sponsor motions tend to agree more with each other.
    -   *Term*: `edgecov(cosponsor_count)` - uses co-sponsorship count as edge covariate

```{r eval=FALSE}

nodelist <- data.frame(
  name = sort(ideology_data$party),
  left_right = ideology_data$left_right[match(sort(ideology_data$party), ideology_data$party)],
  conservative_progressive = ideology_data$conservative_progressive[match(sort(ideology_data$party), ideology_data$party)],
  stringsAsFactors = FALSE
)


g_pre <- igraph::graph_from_data_frame(d = edgelist_pre, vertices = nodelist, directed = FALSE)
g_post <- igraph::graph_from_data_frame(d = edgelist_post, vertices = nodelist, directed = FALSE)

snafun::g_summary(g_pre)
snafun::g_summary(g_post)




```

## Pre election network Prep

```{r eval=FALSE}

## Create cleaned network
# Pre
g_study2_pre_cleaned <- g_study2_pre
snafun::g_summary(g_study2_pre_cleaned)
# Post
g_study2_post_cleaned <- g_study2_post
snafun::g_summary(g_study2_post_cleaned)

g_study2_pre_cleaned
##Remove nodes of parties not present in these elections
# Pre
pre_nodes_to_remove <- c("GroenLinks-PvdA","Omtzigt", "NSC", "BIJ1", "BVNL", '50PLUS')
g_study2_pre_cleaned <- snafun::remove_vertices(g_study2_pre_cleaned,pre_nodes_to_remove)
# Post
post_nodes_to_remove <- c("GroenLinks","Omtzigt", "PvdA", "BIJ1", "BVNL", '50PLUS')
g_study2_post_cleaned <- snafun::remove_vertices(g_study2_post_cleaned,post_nodes_to_remove)


## Edge weight: motion counts as fractions of total motions
# Pre
total_motions_pre  <- length(unique(motion_data_pre$Besluit_Id))
counted_weights_pre <- igraph::E(g_study2_pre_cleaned)$weight
igraph::E(g_study2_pre_cleaned)$weight_count <- counted_weights_pre
igraph::E(g_study2_pre_cleaned)$weight <- counted_weights_pre / total_motions_pre
snafun::g_summary(g_study2_pre_cleaned)
edge_weights_pre <- igraph::E(g_study2_pre_cleaned)$weight
# Post
total_motions_post  <- length(unique(motion_data_post$Besluit_Id))
counted_weights_post <- igraph::E(g_study2_post_cleaned)$weight
igraph::E(g_study2_post_cleaned)$weight_count <- counted_weights_post
igraph::E(g_study2_post_cleaned)$weight <- counted_weights_post / total_motions_post
snafun::g_summary(g_study2_post_cleaned)
edge_weights_post <- igraph::E(g_study2_post_cleaned)$weight


## Cut-off threshold percentages to investigate
#prob <- c(0.25, 0.50, 0.60, 0.68, 0.70, 0.75)
#name <- c("p25","p50","p60","p68", "p70", "p75")

prob <- c(0.60, 0.62, 0.65, 0.68, 0.70, 0.75, 0.8)
name <- c("p60","p62","p65","p68", "p70", "p75", "p80")
#Pre
cutoffs_pre <- quantile(edge_weights_pre, probs = prob, na.rm = TRUE)
cutoffs_pre <- as.list(cutoffs_pre)
names(cutoffs_pre) <- name
# Post
cutoffs_post <- quantile(edge_weights_post, probs = prob, na.rm = TRUE)
cutoffs_post <- as.list(cutoffs_post)
names(cutoffs_post) <- name



g_pre_list <- list()
g_post_list <- list()
dist_pre_list <- list()
dist_post_list <- list()
summary_pre_list <- list()
summary_post_list <- list()

```

### Loop voor alle pre-thresholds

```{r}
for (name in names(cutoffs_pre)){
  threshold <- cutoffs_pre[[name]]
  
  # Subgraph generation
  graph_temporary <- igraph::subgraph.edges(
    g_study2_pre_cleaned,
    eids = igraph::E(g_study2_pre_cleaned)[
      igraph::E(g_study2_pre_cleaned)$weight >= threshold],
    delete.vertices = FALSE
  )
  
  # Binarize Subgraph
  igraph::E(graph_temporary)$weight <- 1
  
  cat("Pre-", name)
  
  summary_temp <- snafun::g_summary(graph_temporary)
  summary_pre_list[[name]] <- summary_temp
  
  print(summary_temp)
  
  snafun::plot(graph_temporary, main = paste("Pre-",name))
  g_pre_list[[name]] <- graph_temporary
  
  # Analyse Subgraph
  dist_pre <- snafun::g_degree_distribution(graph_temporary)
  dist_pre_list[[name]] <- dist_pre
  values <- as.numeric(dist_pre[1, ])
  barplot(values, names.arg = colnames(dist_pre), xlab="Index", ylab="Value", main = paste("Degree distribution pre-", name))
}

for (name in names(g_pre_list)) {
  new_name <- paste("g", name, "pre", sep="_")
  assign(new_name, g_pre_list[[name]])
}

```

#### Loop voor alle post-thresholds

```{r}
for (name in names(cutoffs_post)){
  threshold <- cutoffs_post[[name]]
  
  # Subgraph generation
  graph_temporary <- igraph::subgraph.edges(
    g_study2_post_cleaned,
    eids = igraph::E(g_study2_post_cleaned)[
      igraph::E(g_study2_post_cleaned)$weight >= threshold],
    delete.vertices = FALSE
  )
  
  # Binarize Subgraph
  igraph::E(graph_temporary)$weight <- 1
  
  cat("Post-", name)
  
  summary_temp <- snafun::g_summary(graph_temporary)
  summary_post_list[[name]] <- summary_temp
  
  print(summary_temp)
  
  snafun::plot(graph_temporary, main = paste("Post-",name))
  g_post_list[[name]] <- graph_temporary
  
  # Analyse Subgraph
  dist_post <- snafun::g_degree_distribution(graph_temporary)
  dist_post_list[[name]] <- dist_post
  values <- as.numeric(dist_post[1, ])
  barplot(values, names.arg = colnames(dist_post), xlab="Index", ylab="Value", main = paste("Degree distribution post-", name))
}

for (name in names(g_post_list)) {
  new_name <- paste("g", name, "post", sep="_")
  assign(new_name, g_post_list[[name]])
}

```

#### ERGM Prep

```{r}

thresholded_pre <- g_p65_pre

party_names <- igraph::V(thresholded_pre)$name
igraph::V(thresholded_pre)$left_right <- nodelist$left_right[
  match(party_names, nodelist$name)]
  
thresholded_pre_net <- snafun::to_network(thresholded_pre)

network::set.vertex.attribute(thresholded_pre_net, "left_right", igraph::V(thresholded_pre)$left_right)

coalition_mat  <- as.matrix.network(thresholded_pre_net, attrname = "coalition_count")

#Adding Cosponsor 
edgelist_pre_cosponsor <- read.csv("results/edge_lists/cosponsor_pre_election.csv")

#Filtering edgelist on parties in the network
edgelist_pre_cosponsor_filtered <- subset(edgelist_pre_cosponsor,from %in% party_names & to %in% party_names)
g_pre_cos <- igraph::graph_from_data_frame(edgelist_pre_cosponsor_filtered,FALSE,data.frame(name = party_names))
cosponsor_pre_mat <- igraph::as_adjacency_matrix(g_pre_cos, attr = 'weight', sparse = FALSE)

```

```{r}
## Post

thresholded_post <- g_p65_post

party_names <- igraph::V(thresholded_post)$name
igraph::V(thresholded_post)$left_right <- nodelist$left_right[
  match(party_names, nodelist$name)]
  
thresholded_post_net <- snafun::to_network(thresholded_post)

network::set.vertex.attribute(thresholded_post_net, "left_right", igraph::V(thresholded_post)$left_right)

coalition_post_mat  <- as.matrix.network(thresholded_post_net, attrname = "coalition_count")



#Adding cosponsoring

edgelist_post_cosponsor <- read.csv("results/edge_lists/cosponsor_post_formation.csv")
#Filtering edgelist on parties in the network
edgelist_post_cosponsor_filtered <- subset(edgelist_post_cosponsor,from %in% party_names & to %in% party_names)
g_post_cos <- igraph::graph_from_data_frame(edgelist_post_cosponsor,FALSE,data.frame(name = parties_post))
cosponsor_post_mat <- igraph::as_adjacency_matrix(g_post_cos, attr = 'weight', sparse = FALSE)


```

#### ERGM Run Pre

```{r}
# Exogenous ERGMs

Model1 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    absdiff("left_right") + gwesp(0.1, fixed = TRUE)+ kstar(3),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model2 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    absdiff("left_right") + gwesp(0.3, fixed = TRUE)+ kstar(3),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model3 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    absdiff("left_right") + gwesp(0.5, fixed = TRUE)+ kstar(3),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model4 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model5 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    absdiff("left_right") +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model6 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model7 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    edgecov(coalition_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

texreg::screenreg(list(Model1, Model2, Model3, Model4, Model5, Model6, Model7))

```

```{r}
# Structural ERGMs

Model1 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    gwesp(0.1, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

Model2 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    kstar(3),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)


Model3 <- ergm::ergm(
    thresholded_pre_net ~ 
    edges +
    #gwdegree(0.1, fixed=TRUE) +
    kstar(3)+  
    gwesp(0.1, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

texreg::screenreg(list(Model1, Model2, Model3))

```

```{r}

#Final Model

FinalModel <- ergm::ergm(
    thresholded_pre_net ~ 
    edges + absdiff("left_right") +
    kstar(3) +
    gwesp(0.5, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

texreg::screenreg(list(FinalModel))
```

#### ERGM Interpret Pre

```{r}

ergm_analysis <- function(model, prefix) {

  output_dir <- "results"
  if (!dir.exists(output_dir)) {dir.create(output_dir)}
  
  # Summary
  summary_file <- file.path(output_dir, paste(prefix, "summary.txt"))
  summary_content <- capture.output(summary(model))
  writeLines(summary_content, summary_file)
  cat("Model summary saved in", summary_file, "\n")
  
  # MCMC Diagnostics (plots)
  mcmc_diag_file <- file.path(output_dir, paste(prefix, "mcmc.pdf"))
  pdf(mcmc_diag_file)
  ergm::mcmc.diagnostics(model)
  dev.off()
  cat("MCMC saved in ", mcmc_diag_file, "\n")
  
  # GOF (plots)
  gof_results <- ergm::gof(model)
  gof_plot_file <- file.path(output_dir, paste(prefix, "gof.pdf"))
  pdf(gof_plot_file)
  snafun::stat_plot_gof(gof_results)
  dev.off()
  cat("GOF saved in", gof_plot_file, "\n")

}

ergm_analysis(FinalModel, "pre-election")

```

#### ERGM Run Post

```{r}
# Exogenous ERGMs

Model1 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model2 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(cosponsor_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model3 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model4 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model5 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    absdiff("left_right") +
    edgecov(coalition_mat),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model6 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

Model7 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    edgecov(cosponsor_mat) +
    edgecov(coalition_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 7000,
    MCMC.samplesize = 20000,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK"
  )
)

texreg::screenreg(list(Model1, Model2, Model3, Model4, Model5, Model6, Model7))

```

```{r}
# Structural ERGMs

Model1 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    gwesp(0.1, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

Model2 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    kstar(2),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)


Model3 <- ergm::ergm(
    thresholded_post_net ~ 
    edges +
    #gwdegree(0.1, fixed=TRUE) +
    kstar(2)+  
    gwesp(0.1, fixed = TRUE),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)

texreg::screenreg(list(Model1, Model2, Model3))

```

```{r}

#Final Model

FinalModel <- ergm::ergm(
  thresholded_post_net ~
    edges + kstar(3) + gwesp(0.5, fixed = TRUE) +
    edgecov(cosponsor_post_mat) +
    edgecov(coalition_post_mat) +
    absdiff("left_right"),
  control = ergm::control.ergm(
    MCMC.burnin = 20000,
    MCMC.samplesize = 25000,
    MCMC.interval = 1500,
    seed = 1234,
    MCMLE.maxit = 40,
    parallel = 5,
    parallel.type = "PSOCK",
    MCMC.prop = ~sparse + .triadic
  )
)
```

```{r}

texreg::screenreg(list(FinalModel))
```

#### ERGM Interpret Pre

```{r}
ergm_analysis(FinalModel, "post-election")
```

# 7. Summary

## 7.1 Preprocessing Summary

```{r summary}
print("PREPROCESSING SUMMARY")
print("====================")
print("")
print("DATA PREPARATION:")
print(sprintf("  • Pre-election: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_pre), big.mark = ","),
              format(length(unique(motion_data_pre$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_pre$ActorFractie))))
print(sprintf("  • Post-formation: %s votes, %s motions, %d parties", 
              format(nrow(motion_data_post), big.mark = ","),
              format(length(unique(motion_data_post$Besluit_Id)), big.mark = ","),
              length(unique(motion_data_post$ActorFractie))))
print("")
print("FULLY CONNECTED NETWORKS (GENERAL PREPROCESSING):")
print(sprintf("  • Pre-election: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_pre_connected), snafun::count_edges(g_pre_connected)))
print(sprintf("  • Post-formation: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_post_connected), snafun::count_edges(g_post_connected)))
print("  • All zero edge weights set to 1e-6 for full connectivity")
print("  • Adjacency matrices exported")
print("")
print("STUDY 1 (QAP):")
print("  • Uses fully connected networks from general preprocessing")
print("  • Ready for QAP correlation test")
print("")
print("STUDY 2 (GERGM):")
print(sprintf("  • Pre-election: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_pre), snafun::count_edges(g_study2_pre)))
print(sprintf("  • Post-formation: %d nodes, fully connected (%d edges)", 
              snafun::count_vertices(g_study2_post), snafun::count_edges(g_study2_post)))
print("  • Same node set for comparability between periods")
print("  • Ideology, co-sponsorship, and coalition attributes added")
print("  • Ready for GERGM analysis")
```

## 7.2 Files Generated

All preprocessing outputs have been saved to:

-   **Adjacency Matrices:** `results/adjacency_matrices/`
    -   `pre_election_adjacency.csv`
    -   `post_formation_adjacency.csv`
-   **Statistics:** `results/statistics/`
-   **Visualizations:** `results/visualizations/`

------------------------------------------------------------------------

# Session Info

```{r session-info}
sessionInfo()
```
